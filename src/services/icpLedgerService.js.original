// ICP Ledger Service
// This file provides interfaces to interact with the ICP Ledger canister

// Import real @dfinity packages - replaced with our browser-compatible versions
import { idlFactory as ledgerIdlFactory } from './did/ledger.did.js';
import { 
  principalToAccountIdentifier,
  accountIdToHex,
  hexToAccountId,
  icpToE8s,
  e8sToIcp,
  ICP_LEDGER_CANISTER_ID,
  SUB_ACCOUNT_ZERO,
  ACCOUNT_DOMAIN_SEPARATOR
} from './icp-crypto';
import { identityService } from './identityService';

// Default fee in e8s (0.0001 ICP)
const DEFAULT_TRANSFER_FEE = BigInt(10000);

// Helper to create an actor for interacting with the ledger
const createLedgerActorHelper = async (identity = null) => {
  try {
    // Create an agent for interacting with the IC
    const agent = new HttpAgent({
      identity,
      host: process.env.VITE_ICP_HOST || 'https://ic0.app',
    });

    // In development, we might need to fetch the root key
    if (process.env.NODE_ENV !== 'production') {
      await agent.fetchRootKey();
    }

    // Create an actor to interact with the ledger canister
    return Actor.createActor(ledgerIdlFactory, {
      agent,
      canisterId: ICP_LEDGER_CANISTER_ID,
    });
  } catch (error) {
    console.error("Error creating ledger actor:", error);
    throw error;
  }
};

/**
 * ICP Ledger Service for handling payments and balance queries
 */
class ICPLedgerService {
  constructor() {
    this.ledgerActor = null;
    this.isInitialized = false;
    this.identity = null;
    this.transferFee = DEFAULT_TRANSFER_FEE;
  }

  /**
   * Initialize the ledger service
   * @param {SignIdentity} identity - The identity to use for ledger interactions
   */
  async initialize(identity) {
    try {
      this.identity = identity;
      this.ledgerActor = await createLedgerActorHelper(identity);
      
      // Get the current transfer fee
      try {
        const feeResponse = await this.ledgerActor.transfer_fee({});
        this.transferFee = feeResponse.transfer_fee.e8s;
        console.log(`ICP transfer fee: ${e8sToIcp(this.transferFee)} ICP`);
      } catch (error) {
        console.warn("Could not get transfer fee, using default:", error);
      }
      
      this.isInitialized = true;
      console.log('ICP Ledger service initialized');
      return true;
    } catch (error) {
      console.error("Failed to initialize ICP ledger service:", error);
      this.isInitialized = false;
      throw error;
    }
  }

  /**
   * Get the principal ID associated with the current identity
   * @returns {Principal|null} - The principal ID or null if not initialized
   */
  getPrincipal() {
    if (!this.identity) {
      console.warn("No identity set");
      return null;
    }
    return this.identity.getPrincipal();
  }
  
  /**
   * Get the account ID for the current principal
   * @param {Uint8Array} subAccount - Optional subaccount (defaults to 0)
   * @returns {Uint8Array} - The account ID
   */
  getAccountId(subAccount = SUB_ACCOUNT_ZERO) {
    const principal = this.getPrincipal();
    if (!principal) {
      console.warn("No principal available");
      // Return a mock account ID
      return new Uint8Array(32).fill(1);
    }
    return principalToAccountIdentifier(principal, subAccount);
  }
  
  /**
   * Get the account ID as a hex string
   * @returns {string} - The account ID as a hex string
   */
  getAccountIdHex() {
    return accountIdToHex(this.getAccountId());
  }

  /**
   * Get the balance of an account
   * @param {string|Principal|Uint8Array} accountId - The account identifier, can be:
   *   - A hex string
   *   - A Principal object (will be converted to default account ID)
   *   - A Uint8Array account ID
   * @returns {Promise<number>} - The balance in ICP
   */
  async getBalance(accountId) {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      let accountIdBytes;
      
      // Handle different input types
      if (typeof accountId === 'string') {
        // Assume it's a hex string
        accountIdBytes = hexToAccountId(accountId);
      } else if (accountId instanceof Principal) {
        // Convert principal to account ID
        accountIdBytes = principalToAccountIdentifier(accountId);
      } else if (accountId instanceof Uint8Array) {
        // Already in the right format
        accountIdBytes = accountId;
      } else {
        // Use the current user's account ID
        accountIdBytes = this.getAccountId();
      }
      
      // Query the ledger for balance
      const balanceE8s = await this.ledgerActor.account_balance(accountIdBytes);
      
      return e8sToIcp(balanceE8s.e8s);
    } catch (error) {
      console.error("Error fetching balance:", error);
      throw error;
    }
  }

  /**
   * Transfer ICP from one account to another
   * @param {string|Principal} to - The recipient's principal ID or account ID hex string
   * @param {number} amountIcp - The amount to transfer in ICP
   * @param {Object} options - Additional options for the transfer
   * @returns {Promise<Object>} - The result of the transfer
   */
  async transfer(to, amountIcp, options = {}) {
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      const memo = options.memo || BigInt(Date.now());
      const amountE8s = icpToE8s(amountIcp);
      let toAccountId;
      
      // Convert recipient to account ID based on input type
      if (typeof to === 'string' && to.length === 64) {
        // Assume it's already an account ID in hex format
        toAccountId = hexToAccountId(to);
      } else if (to instanceof Principal) {
        // Convert principal to account ID
        toAccountId = principalToAccountIdentifier(to);
      } else if (typeof to === 'string') {
        // Assume it's a principal ID text
        toAccountId = principalToAccountIdentifier(Principal.fromText(to));
      } else {
        throw new Error("Invalid recipient format");
      }

      // Create transfer arguments
      const transferArgs = {
        from_subaccount: [], // Default subaccount
        to: toAccountId,
        amount: { e8s: amountE8s },
        fee: { e8s: this.transferFee },
        memo: BigInt(memo),
        created_at_time: [{ timestamp_nanos: BigInt(Date.now() * 1000000) }]
      };
      
      // Execute the transfer
      const result = await this.ledgerActor.transfer(transferArgs);

      if ('Ok' in result) {
        // Success case
        return {
          success: true,
          blockHeight: result.Ok.toString(),
          transactionId: `${result.Ok}-${memo}`,
          amount: amountIcp,
          fee: e8sToIcp(this.transferFee),
          timestamp: Date.now(),
          from: this.getAccountIdHex(),
          to: accountIdToHex(toAccountId)
        };
      } else {
        // Error case
        const error = Object.keys(result.Err)[0];
        const errorDetails = result.Err[error];
        return {
          success: false,
          error,
          errorDetails,
          amount: amountIcp,
          from: this.getAccountIdHex(),
          to: accountIdToHex(toAccountId)
        };
      }
    } catch (error) {
      console.error("Error transferring funds:", error);
      throw error;
    }
  }
  
  /**
   * Get transaction history
   * @param {object} params - Query parameters
   * @param {number} [params.start] - Start index
   * @param {number} [params.length] - Number of transactions to retrieve
   * @returns {Promise<Array>} Transaction history
   */
  async getTransactions({ start = 0, length = 10 } = {}) {
    try {
      if (!this.isInitialized) {
        throw new Error('ICP ledger service not initialized');
      }

      // Get account ID for the current identity
      const accountIdHex = this.getAccountIdHex();
      
      // Use the history service to get transaction history
      const { getCurrentUserTransactionHistory } = await import('./historyService');
      return await getCurrentUserTransactionHistory({
        limit: length,
        offset: start
      });
    } catch (error) {
      console.error('Error getting transactions:', error);
      throw error;
    }
  }
  
  /**
   * Pay for data from a provider
   * @param {string} providerId - The provider's principal ID
   * @param {number} amount - Amount to pay in ICP
   * @param {string} dataDescription - Description of the data being purchased
   * @returns {Promise<object>} The result of the payment
   */
  async payForData(providerId, amount, dataDescription) {
    try {
      if (!this.isInitialized) {
        throw new Error('ICP ledger service not initialized');
      }
      
      // Convert provider principal to account ID
      const providerPrincipal = Principal.fromText(providerId);
      const providerAccountId = principalToAccountIdentifier(providerPrincipal);
      const providerAccountHex = accountIdToHex(providerAccountId);
      
      // Create a memo that includes information about the data purchase
      // This is a simplified approach - in a real system you might
      // want to use a more sophisticated approach to track data purchases
      const memoText = `data:${dataDescription}`;
      const encoder = new TextEncoder();
      const memoBytes = encoder.encode(memoText);
      let memoNumber = 0;
      for (let i = 0; i < memoBytes.length && i < 8; i++) {
        memoNumber = (memoNumber << 8) | memoBytes[i];
      }
      
      // Make the transfer
      const result = await this.transfer(
        providerAccountHex,
        amount,
        { memo: memoNumber.toString() }
      );
      
      // Record the payment with reputation agents
      if (result.success) {
        try {
          const { reputationService } = await import('./reputationService');
          const reputationResults = await reputationService.recordTransaction({
            type: 'data_purchase',
            provider: providerId,
            amount,
            description: dataDescription,
            transactionId: result.transactionId,
            blockHeight: result.blockHeight
          });
          
          console.log('Transaction recorded with reputation agents:', reputationResults);
        } catch (repError) {
          console.error('Error recording transaction with reputation agents:', repError);
          // We don't fail the overall transaction if reputation recording fails
        }
      }
      
      return {
        ...result,
        provider: providerId,
        description: dataDescription
      };
    } catch (error) {
      console.error('Error paying for data:', error);
      throw error;
    }
  }
}

// Export a singleton instance
export const icpLedgerService = new ICPLedgerService();

// Export interface for agent integration
export const initiatePayment = async (amountInICP, providerPrincipalId, description = "") => {
  try {
    console.log(`Initiating payment: ${amountInICP} ICP to ${providerPrincipalId}`);
    
    // Use the payForData method for proper data purchase tracking
    const result = await icpLedgerService.payForData(
      providerPrincipalId,
      amountInICP,
      description
    );
    
    return result;
  } catch (error) {
    console.error("Error initiating payment:", error);
    throw error;
  }
};

export default icpLedgerService;
