{
  "version": 3,
  "sources": ["../../node_modules/@dfinity/candid/src/index.ts", "../../node_modules/@dfinity/candid/src/candid-ui.ts", "../../node_modules/@dfinity/candid/src/idl.ts", "../../node_modules/@dfinity/candid/src/utils/buffer.ts", "../../node_modules/@dfinity/candid/src/utils/hash.ts", "../../node_modules/@dfinity/candid/src/utils/leb128.ts", "../../node_modules/@dfinity/candid/src/utils/bigint-math.ts", "../../node_modules/@dfinity/candid/src/candid-core.ts", "../../node_modules/@dfinity/candid/src/types.ts"],
  "sourcesContent": ["export * from './candid-ui.ts';\nexport * from './candid-core.ts';\nexport * as IDL from './idl.ts';\nexport {\n  type GenericIdlFuncArgs,\n  type GenericIdlFuncRets,\n  type GenericIdlServiceFields,\n} from './idl.ts';\nexport * from './utils/hash.ts';\nexport * from './utils/leb128.ts';\nexport * from './utils/buffer.ts';\nexport * from './types.ts';\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as IDL from './idl.ts';\nimport { Principal } from '@dfinity/principal';\nimport * as UI from './candid-core.ts';\n\ntype InputBox = UI.InputBox;\n\nconst InputConfig: UI.UIConfig = { parse: parsePrimitive };\nconst FormConfig: UI.FormConfig = { render: renderInput };\n\nexport const inputBox = (t: IDL.Type, config: Partial<UI.UIConfig>) => {\n  return new UI.InputBox(t, { ...InputConfig, ...config });\n};\nexport const recordForm = (fields: Array<[string, IDL.Type]>, config: Partial<UI.FormConfig>) => {\n  return new UI.RecordForm(fields, { ...FormConfig, ...config });\n};\nexport const tupleForm = (components: IDL.Type[], config: Partial<UI.FormConfig>) => {\n  return new UI.TupleForm(components, { ...FormConfig, ...config });\n};\nexport const variantForm = (fields: Array<[string, IDL.Type]>, config: Partial<UI.FormConfig>) => {\n  return new UI.VariantForm(fields, { ...FormConfig, ...config });\n};\nexport const optForm = (ty: IDL.Type, config: Partial<UI.FormConfig>) => {\n  return new UI.OptionForm(ty, { ...FormConfig, ...config });\n};\nexport const vecForm = (ty: IDL.Type, config: Partial<UI.FormConfig>) => {\n  return new UI.VecForm(ty, { ...FormConfig, ...config });\n};\n\nexport class Render extends IDL.Visitor<null, InputBox> {\n  public visitType<T>(t: IDL.Type<T>, _d: null): InputBox {\n    const input = document.createElement('input');\n    input.classList.add('argument');\n    input.placeholder = t.display();\n    return inputBox(t, { input });\n  }\n  public visitNull(t: IDL.NullClass, _d: null): InputBox {\n    return inputBox(t, {});\n  }\n  public visitRecord(t: IDL.RecordClass, fields: Array<[string, IDL.Type]>, _d: null): InputBox {\n    let config = {};\n    if (fields.length > 1) {\n      const container = document.createElement('div');\n      container.classList.add('popup-form');\n      config = { container };\n    }\n    const form = recordForm(fields, config);\n    return inputBox(t as IDL.Type<any>, { form });\n  }\n  public visitTuple<T extends any[]>(\n    t: IDL.TupleClass<T>,\n    components: IDL.Type[],\n    _d: null,\n  ): InputBox {\n    let config = {};\n    if (components.length > 1) {\n      const container = document.createElement('div');\n      container.classList.add('popup-form');\n      config = { container };\n    }\n    const form = tupleForm(components, config);\n    return inputBox(t as IDL.Type<any>, { form });\n  }\n  public visitVariant(t: IDL.VariantClass, fields: Array<[string, IDL.Type]>, _d: null): InputBox {\n    const select = document.createElement('select');\n    for (const [key, _type] of fields) {\n      const option = new Option(key);\n      select.add(option);\n    }\n    select.selectedIndex = -1;\n    select.classList.add('open');\n    const config: Partial<UI.FormConfig> = { open: select, event: 'change' };\n    const form = variantForm(fields, config);\n    return inputBox(t as IDL.Type<any>, { form });\n  }\n  public visitOpt<T>(t: IDL.OptClass<T>, ty: IDL.Type<T>, _d: null): InputBox {\n    const checkbox = document.createElement('input');\n    checkbox.type = 'checkbox';\n    checkbox.classList.add('open');\n    const form = optForm(ty, { open: checkbox, event: 'change' });\n    return inputBox(t as IDL.Type<any>, { form });\n  }\n  public visitVec<T>(t: IDL.VecClass<T>, ty: IDL.Type<T>, _d: null): InputBox {\n    const len = document.createElement('input');\n    len.type = 'number';\n    len.min = '0';\n    len.max = '100';\n    len.style.width = '8rem';\n    len.placeholder = 'len';\n    len.classList.add('open');\n    const container = document.createElement('div');\n    container.classList.add('popup-form');\n    const form = vecForm(ty, { open: len, event: 'change', container });\n    return inputBox(t, { form });\n  }\n  public visitRec<T>(_t: IDL.RecClass<T>, ty: IDL.ConstructType<T>, _d: null): InputBox {\n    return renderInput(ty);\n  }\n}\n\nclass Parse extends IDL.Visitor<string, any> {\n  public visitNull(_t: IDL.NullClass, _v: string): null {\n    return null;\n  }\n  public visitBool(_t: IDL.BoolClass, v: string): boolean {\n    if (v === 'true') {\n      return true;\n    }\n    if (v === 'false') {\n      return false;\n    }\n    throw new Error(`Cannot parse ${v} as boolean`);\n  }\n  public visitText(_t: IDL.TextClass, v: string): string {\n    return v;\n  }\n  public visitFloat(_t: IDL.FloatClass, v: string): number {\n    return parseFloat(v);\n  }\n  public visitFixedInt(t: IDL.FixedIntClass, v: string): number | bigint {\n    if (t._bits <= 32) {\n      return parseInt(v, 10);\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitFixedNat(t: IDL.FixedNatClass, v: string): number | bigint {\n    if (t._bits <= 32) {\n      return parseInt(v, 10);\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitNumber(_t: IDL.PrimitiveType, v: string): bigint {\n    return BigInt(v);\n  }\n  public visitPrincipal(_t: IDL.PrincipalClass, v: string): Principal {\n    return Principal.fromText(v);\n  }\n  public visitService(_t: IDL.ServiceClass, v: string): Principal {\n    return Principal.fromText(v);\n  }\n  public visitFunc(_t: IDL.FuncClass, v: string): [Principal, string] {\n    const x = v.split('.', 2);\n    return [Principal.fromText(x[0]), x[1]];\n  }\n}\n\nclass Random extends IDL.Visitor<string, any> {\n  public visitNull(_t: IDL.NullClass, _v: string): null {\n    return null;\n  }\n  public visitBool(_t: IDL.BoolClass, _v: string): boolean {\n    return Math.random() < 0.5;\n  }\n  public visitText(_t: IDL.TextClass, _v: string): string {\n    return Math.random().toString(36).substring(6);\n  }\n  public visitFloat(_t: IDL.FloatClass, _v: string): number {\n    return Math.random();\n  }\n  public visitInt(_t: IDL.IntClass, _v: string): bigint {\n    return BigInt(this.generateNumber(true));\n  }\n  public visitNat(_t: IDL.NatClass, _v: string): bigint {\n    return BigInt(this.generateNumber(false));\n  }\n  public visitFixedInt(t: IDL.FixedIntClass, v: string): number | bigint {\n    const x = this.generateNumber(true);\n    if (t._bits <= 32) {\n      return x;\n    } else {\n      return BigInt(v);\n    }\n  }\n  public visitFixedNat(t: IDL.FixedNatClass, v: string): number | bigint {\n    const x = this.generateNumber(false);\n    if (t._bits <= 32) {\n      return x;\n    } else {\n      return BigInt(v);\n    }\n  }\n  private generateNumber(signed: boolean): number {\n    const num = Math.floor(Math.random() * 100);\n    if (signed && Math.random() < 0.5) {\n      return -num;\n    } else {\n      return num;\n    }\n  }\n}\n\nfunction parsePrimitive(t: IDL.Type, config: UI.ParseConfig, d: string) {\n  if (config.random && d === '') {\n    return t.accept(new Random(), d);\n  } else {\n    return t.accept(new Parse(), d);\n  }\n}\n\n/**\n *\n * @param t an IDL type\n * @returns an input for that type\n */\nexport function renderInput(t: IDL.Type): InputBox {\n  return t.accept(new Render(), null);\n}\n\ninterface ValueConfig {\n  input: InputBox;\n  value: any;\n}\n\n/**\n *\n * @param t an IDL Type\n * @param input an InputBox\n * @param value any\n * @returns rendering that value to the provided input\n */\nexport function renderValue(t: IDL.Type, input: InputBox, value: any) {\n  return t.accept(new RenderValue(), { input, value });\n}\n\nclass RenderValue extends IDL.Visitor<ValueConfig, void> {\n  public visitType<T>(t: IDL.Type<T>, d: ValueConfig) {\n    (d.input.ui.input as HTMLInputElement).value = t.valueToString(d.value);\n  }\n\n  public visitNull(_t: IDL.NullClass, _d: ValueConfig) {}\n  public visitText(_t: IDL.TextClass, d: ValueConfig) {\n    (d.input.ui.input as HTMLInputElement).value = d.value;\n  }\n  public visitRec<T>(_t: IDL.RecClass<T>, ty: IDL.ConstructType<T>, d: ValueConfig): void {\n    renderValue(ty, d.input, d.value);\n  }\n  public visitOpt<T>(_t: IDL.OptClass<T>, ty: IDL.Type<T>, d: ValueConfig): void {\n    if (d.value.length === 0) {\n      return;\n    } else {\n      const form = d.input.ui.form!;\n      const open = form.ui.open as HTMLInputElement;\n      open.checked = true;\n      open.dispatchEvent(new Event(form.ui.event!));\n      renderValue(ty, form.form[0], d.value[0]);\n    }\n  }\n  public visitRecord(_t: IDL.RecordClass, fields: Array<[string, IDL.Type]>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    fields.forEach(([key, type], i) => {\n      renderValue(type, form.form[i], d.value[key]);\n    });\n  }\n  public visitTuple<T extends any[]>(\n    _t: IDL.TupleClass<T>,\n    components: IDL.Type[],\n    d: ValueConfig,\n  ) {\n    const form = d.input.ui.form!;\n    components.forEach((type, i) => {\n      renderValue(type, form.form[i], d.value[i]);\n    });\n  }\n  public visitVariant(_t: IDL.VariantClass, fields: Array<[string, IDL.Type]>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    const selected = Object.entries(d.value)[0];\n    fields.forEach(([key, type], i) => {\n      if (key === selected[0]) {\n        const open = form.ui.open as HTMLSelectElement;\n        open.selectedIndex = i;\n        open.dispatchEvent(new Event(form.ui.event!));\n        renderValue(type, form.form[0], selected[1]);\n      }\n    });\n  }\n  public visitVec<T>(_t: IDL.VecClass<T>, ty: IDL.Type<T>, d: ValueConfig) {\n    const form = d.input.ui.form!;\n    const len = d.value.length;\n    const open = form.ui.open as HTMLInputElement;\n    open.value = len;\n    open.dispatchEvent(new Event(form.ui.event!));\n    d.value.forEach((v: T, i: number) => {\n      renderValue(ty, form.form[i], v);\n    });\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Principal as PrincipalId } from '@dfinity/principal';\nimport { type JsonValue } from './types.ts';\nimport { concat, PipeArrayBuffer as Pipe, uint8ToDataView } from './utils/buffer.ts';\nimport { idlLabelToId } from './utils/hash.ts';\nimport {\n  lebDecode,\n  lebEncode,\n  readIntLE,\n  readUIntLE,\n  safeRead,\n  safeReadUint8,\n  slebDecode,\n  slebEncode,\n  writeIntLE,\n  writeUIntLE,\n} from './utils/leb128.ts';\nimport { iexp2 } from './utils/bigint-math.ts';\n\n/**\n * This module provides a combinator library to create serializers/deserializers\n * between JavaScript values and IDL used by canisters on the Internet Computer,\n * as documented at https://github.com/dfinity/candid/blob/119703ba342d2fef6ab4972d2541b9fe36ae8e36/spec/Candid.md\n */\n\nenum IDLTypeIds {\n  Null = -1,\n  Bool = -2,\n  Nat = -3,\n  Int = -4,\n  Float32 = -13,\n  Float64 = -14,\n  Text = -15,\n  Reserved = -16,\n  Empty = -17,\n  Opt = -18,\n  Vector = -19,\n  Record = -20,\n  Variant = -21,\n  Func = -22,\n  Service = -23,\n  Principal = -24,\n}\n\nconst magicNumber = 'DIDL';\nconst toReadableString_max = 400; // will not display arguments after 400chars. Makes sure 2mb blobs don't get inside the error\n\nfunction zipWith<TX, TY, TR>(xs: TX[], ys: TY[], f: (a: TX, b: TY) => TR): TR[] {\n  return xs.map((x, i) => f(x, ys[i]));\n}\n\n/**\n * An IDL Type Table, which precedes the data in the stream.\n */\nclass TypeTable {\n  // List of types. Needs to be an array as the index needs to be stable.\n  private _typs: Uint8Array[] = [];\n  private _idx = new Map<string, number>();\n\n  public has(obj: ConstructType) {\n    return this._idx.has(obj.name);\n  }\n\n  public add<T>(type: ConstructType<T>, buf: Uint8Array) {\n    const idx = this._typs.length;\n    this._idx.set(type.name, idx);\n    this._typs.push(buf);\n  }\n\n  public merge<T>(obj: ConstructType<T>, knot: string) {\n    const idx = this._idx.get(obj.name);\n    const knotIdx = this._idx.get(knot);\n    if (idx === undefined) {\n      throw new Error('Missing type index for ' + obj);\n    }\n    if (knotIdx === undefined) {\n      throw new Error('Missing type index for ' + knot);\n    }\n    this._typs[idx] = this._typs[knotIdx];\n\n    // Delete the type.\n    this._typs.splice(knotIdx, 1);\n    this._idx.delete(knot);\n  }\n\n  public encode(): Uint8Array {\n    const len = lebEncode(this._typs.length);\n    const buf = concat(...this._typs);\n    return concat(len, buf);\n  }\n\n  public indexOf(typeName: string): Uint8Array {\n    if (!this._idx.has(typeName)) {\n      throw new Error('Missing type index for ' + typeName);\n    }\n    return slebEncode(this._idx.get(typeName) || 0);\n  }\n}\n\nexport abstract class Visitor<D, R> {\n  public visitType<T>(_t: Type<T>, _data: D): R {\n    throw new Error('Not implemented');\n  }\n  public visitPrimitive<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitEmpty(t: EmptyClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitBool(t: BoolClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNull(t: NullClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitReserved(t: ReservedClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitText(t: TextClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitNumber<T>(t: PrimitiveType<T>, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitInt(t: IntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitNat(t: NatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFloat(t: FloatClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n  public visitFixedInt(t: FixedIntClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitFixedNat(t: FixedNatClass, data: D): R {\n    return this.visitNumber(t, data);\n  }\n  public visitPrincipal(t: PrincipalClass, data: D): R {\n    return this.visitPrimitive(t, data);\n  }\n\n  public visitConstruct<T>(t: ConstructType<T>, data: D): R {\n    return this.visitType(t, data);\n  }\n  public visitVec<T>(t: VecClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitOpt<T>(t: OptClass<T>, _ty: Type<T>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRecord(t: RecordClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitTuple<T extends any[]>(t: TupleClass<T>, components: Type[], data: D): R {\n    const fields: Array<[string, Type]> = components.map((ty, i) => [`_${i}_`, ty]);\n    return this.visitRecord(t, fields, data);\n  }\n  public visitVariant(t: VariantClass, _fields: Array<[string, Type]>, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitRec<T>(_t: RecClass<T>, ty: ConstructType<T>, data: D): R {\n    return this.visitConstruct(ty, data);\n  }\n  public visitFunc(t: FuncClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n  public visitService(t: ServiceClass, data: D): R {\n    return this.visitConstruct(t, data);\n  }\n}\n\n// We try to use hard-to-accidentally-pick names to avoid potential collisions with other types.\nenum IdlTypeName {\n  EmptyClass = '__IDL_EmptyClass__',\n  UnknownClass = '__IDL_UnknownClass__',\n  BoolClass = '__IDL_BoolClass__',\n  NullClass = '__IDL_NullClass__',\n  ReservedClass = '__IDL_ReservedClass__',\n  TextClass = '__IDL_TextClass__',\n  IntClass = '__IDL_IntClass__',\n  NatClass = '__IDL_NatClass__',\n  FloatClass = '__IDL_FloatClass__',\n  FixedIntClass = '__IDL_FixedIntClass__',\n  FixedNatClass = '__IDL_FixedNatClass__',\n  VecClass = '__IDL_VecClass__',\n  OptClass = '__IDL_OptClass__',\n  RecordClass = '__IDL_RecordClass__',\n  TupleClass = '__IDL_TupleClass__',\n  VariantClass = '__IDL_VariantClass__',\n  RecClass = '__IDL_RecClass__',\n  PrincipalClass = '__IDL_PrincipalClass__',\n  FuncClass = '__IDL_FuncClass__',\n  ServiceClass = '__IDL_ServiceClass__',\n}\n\n/**\n * Represents an IDL type.\n */\nexport abstract class Type<T = any> {\n  public abstract readonly typeName: IdlTypeName;\n  public abstract readonly name: string;\n  public abstract accept<D, R>(v: Visitor<D, R>, d: D): R;\n\n  /* Display type name */\n  public display(): string {\n    return this.name;\n  }\n\n  public valueToString(x: T): string {\n    return toReadableString(x);\n  }\n\n  /* Implement `T` in the IDL spec, only needed for non-primitive types */\n  public buildTypeTable(typeTable: TypeTable): void {\n    if (!typeTable.has(this)) {\n      this._buildTypeTableImpl(typeTable);\n    }\n  }\n\n  /**\n   * Assert that JavaScript's `x` is the proper type represented by this\n   * Type.\n   */\n  public abstract covariant(x: any): x is T;\n\n  /**\n   * Encode the value. This needs to be public because it is used by\n   * encodeValue() from different types.\n   * @internal\n   */\n  public abstract encodeValue(x: T): Uint8Array;\n\n  /**\n   * Implement `I` in the IDL spec.\n   * Encode this type for the type table.\n   */\n  public abstract encodeType(typeTable: TypeTable): Uint8Array;\n\n  public abstract checkType(t: Type): Type;\n\n  public abstract decodeValue(x: Pipe, t: Type): T;\n\n  protected abstract _buildTypeTableImpl(typeTable: TypeTable): void;\n}\n\nexport abstract class PrimitiveType<T = any> extends Type<T> {\n  public checkType(t: Type): Type {\n    if (this.name !== t.name) {\n      throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n    }\n    return t;\n  }\n\n  public _buildTypeTableImpl(_typeTable: TypeTable): void {\n    // No type table encoding for Primitive types.\n    return;\n  }\n}\n\nexport abstract class ConstructType<T = any> extends Type<T> {\n  public checkType(t: Type): ConstructType<T> {\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      }\n      return ty;\n    }\n    throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`);\n  }\n  public encodeType(typeTable: TypeTable) {\n    return typeTable.indexOf(this.name);\n  }\n}\n\n/**\n * Represents an IDL Empty, a type which has no inhabitants.\n * Since no values exist for this type, it cannot be serialised or deserialised.\n * Result types like `Result<Text, Empty>` should always succeed.\n */\nexport class EmptyClass extends PrimitiveType<never> {\n  get typeName() {\n    return IdlTypeName.EmptyClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is EmptyClass {\n    return instance.typeName === IdlTypeName.EmptyClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitEmpty(this, d);\n  }\n\n  public covariant(x: any): x is never {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Empty cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Empty cannot appear as a value');\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Empty);\n  }\n\n  public decodeValue(): never {\n    throw new Error('Empty cannot appear as an output');\n  }\n\n  get name() {\n    return 'empty';\n  }\n}\n\n/**\n * Represents an IDL Unknown, a placeholder type for deserialization only.\n * When decoding a value as Unknown, all fields will be retained but the names are only available in\n * hashed form.\n * A deserialized unknown will offer it's actual type by calling the `type()` function.\n * Unknown cannot be serialized and attempting to do so will throw an error.\n */\nexport class UnknownClass extends Type {\n  get typeName() {\n    return IdlTypeName.UnknownClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is UnknownClass {\n    return instance.typeName === IdlTypeName.UnknownClass;\n  }\n\n  public checkType(_t: Type): Type {\n    throw new Error('Method not implemented for unknown.');\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    throw v.visitType(this, d);\n  }\n\n  public covariant(x: any): x is any {\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): never {\n    throw new Error('Unknown cannot appear as a function argument');\n  }\n\n  public valueToString(): never {\n    throw new Error('Unknown cannot appear as a value');\n  }\n\n  public encodeType(): never {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  public decodeValue(b: Pipe, t: Type): any {\n    let decodedValue = t.decodeValue(b, t);\n\n    if (Object(decodedValue) !== decodedValue) {\n      // decodedValue is primitive. Box it, otherwise we cannot add the type() function.\n      // The type() function is important for primitives because otherwise we cannot tell apart the\n      // different number types.\n      decodedValue = Object(decodedValue);\n    }\n\n    let typeFunc;\n    if (t instanceof RecClass) {\n      typeFunc = () => t.getType();\n    } else {\n      typeFunc = () => t;\n    }\n    // Do not use 'decodedValue.type = typeFunc' because this would lead to an enumerable property\n    // 'type' which means it would be serialized if the value would be candid encoded again.\n    // This in turn leads to problems if the decoded value is a variant because these values are\n    // only allowed to have a single property.\n    Object.defineProperty(decodedValue, 'type', {\n      value: typeFunc,\n      writable: true,\n      enumerable: false,\n      configurable: true,\n    });\n    return decodedValue;\n  }\n\n  protected _buildTypeTableImpl(): void {\n    throw new Error('Unknown cannot be serialized');\n  }\n\n  get name() {\n    return 'Unknown';\n  }\n}\n\n/**\n * Represents an IDL Bool\n */\nexport class BoolClass extends PrimitiveType<boolean> {\n  get typeName() {\n    return IdlTypeName.BoolClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is BoolClass {\n    return instance.typeName === IdlTypeName.BoolClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitBool(this, d);\n  }\n\n  public covariant(x: any): x is boolean {\n    if (typeof x === 'boolean') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: boolean): Uint8Array {\n    return new Uint8Array([x ? 1 : 0]);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Bool);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    switch (safeReadUint8(b)) {\n      case 0:\n        return false;\n      case 1:\n        return true;\n      default:\n        throw new Error('Boolean value out of range');\n    }\n  }\n\n  get name() {\n    return 'bool';\n  }\n}\n\n/**\n * Represents an IDL Null\n */\nexport class NullClass extends PrimitiveType<null> {\n  get typeName() {\n    return IdlTypeName.NullClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NullClass {\n    return instance.typeName === IdlTypeName.NullClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNull(this, d);\n  }\n\n  public covariant(x: any): x is null {\n    if (x === null) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Null);\n  }\n\n  public decodeValue(_b: Pipe, t: Type) {\n    this.checkType(t);\n    return null;\n  }\n\n  get name() {\n    return 'null';\n  }\n}\n\n/**\n * Represents an IDL Reserved\n */\nexport class ReservedClass extends PrimitiveType<any> {\n  get typeName() {\n    return IdlTypeName.ReservedClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ReservedClass {\n    return instance.typeName === IdlTypeName.ReservedClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitReserved(this, d);\n  }\n\n  public covariant(_x: any): _x is any {\n    return true;\n  }\n\n  public encodeValue(): Uint8Array {\n    return new Uint8Array(0);\n  }\n\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Reserved);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (t.name !== this.name) {\n      t.decodeValue(b, t);\n    }\n    return null;\n  }\n\n  get name() {\n    return 'reserved';\n  }\n}\n\n/**\n * Represents an IDL Text\n */\nexport class TextClass extends PrimitiveType<string> {\n  get typeName() {\n    return IdlTypeName.TextClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is TextClass {\n    return instance.typeName === IdlTypeName.TextClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitText(this, d);\n  }\n\n  public covariant(x: any): x is string {\n    if (typeof x === 'string') return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: string) {\n    const buf = new TextEncoder().encode(x);\n    const len = lebEncode(buf.byteLength);\n    return concat(len, buf);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Text);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const len = lebDecode(b);\n    const buf = safeRead(b, Number(len));\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    return decoder.decode(buf);\n  }\n\n  get name() {\n    return 'text';\n  }\n\n  public valueToString(x: string) {\n    return '\"' + x + '\"';\n  }\n}\n\n/**\n * Represents an IDL Int\n */\nexport class IntClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.IntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is IntClass {\n    return instance.typeName === IdlTypeName.IntClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if (typeof x === 'bigint' || Number.isInteger(x)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return slebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Int);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return slebDecode(b);\n  }\n\n  get name() {\n    return 'int';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Nat\n */\nexport class NatClass extends PrimitiveType<bigint> {\n  get typeName() {\n    return IdlTypeName.NatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is NatClass {\n    return instance.typeName === IdlTypeName.NatClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    // We allow encoding of JavaScript plain numbers.\n    // But we will always decode to bigint.\n    if ((typeof x === 'bigint' && x >= BigInt(0)) || (Number.isInteger(x) && x >= 0)) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number): Uint8Array {\n    return lebEncode(x);\n  }\n\n  public encodeType() {\n    return slebEncode(IDLTypeIds.Nat);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    return lebDecode(b);\n  }\n\n  get name() {\n    return 'nat';\n  }\n\n  public valueToString(x: bigint) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Float\n */\nexport class FloatClass extends PrimitiveType<number> {\n  get typeName() {\n    return IdlTypeName.FloatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FloatClass {\n    return instance.typeName === IdlTypeName.FloatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n    if (_bits !== 32 && _bits !== 64) {\n      throw new Error('not a valid float type');\n    }\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFloat(this, d);\n  }\n\n  public covariant(x: any): x is number {\n    if (typeof x === 'number' || x instanceof Number) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: number) {\n    const buf = new ArrayBuffer(this._bits / 8);\n    const view = new DataView(buf);\n    if (this._bits === 32) {\n      view.setFloat32(0, x, true);\n    } else {\n      view.setFloat64(0, x, true);\n    }\n    return new Uint8Array(buf);\n  }\n\n  public encodeType(): Uint8Array {\n    const opcode = this._bits === 32 ? IDLTypeIds.Float32 : IDLTypeIds.Float64;\n    return slebEncode(opcode);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const bytes = safeRead(b, this._bits / 8);\n    const view = uint8ToDataView(bytes);\n    if (this._bits === 32) {\n      return view.getFloat32(0, true);\n    } else {\n      return view.getFloat64(0, true);\n    }\n  }\n\n  get name() {\n    return 'float' + this._bits;\n  }\n\n  public valueToString(x: number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Int(n)\n */\nexport class FixedIntClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedIntClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedIntClass {\n    return instance.typeName === IdlTypeName.FixedIntClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedInt(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const min = iexp2(this._bits - 1) * BigInt(-1);\n    const max = iexp2(this._bits - 1) - BigInt(1);\n    let ok = false;\n    if (typeof x === 'bigint') {\n      ok = x >= min && x <= max;\n    } else if (Number.isInteger(x)) {\n      const v = BigInt(x);\n      ok = v >= min && v <= max;\n    } else {\n      ok = false;\n    }\n\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-9 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `int${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL fixed-width Nat(n)\n */\nexport class FixedNatClass extends PrimitiveType<bigint | number> {\n  get typeName() {\n    return IdlTypeName.FixedNatClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FixedNatClass {\n    return instance.typeName === IdlTypeName.FixedNatClass;\n  }\n\n  constructor(public readonly _bits: number) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFixedNat(this, d);\n  }\n\n  public covariant(x: any): x is bigint {\n    const max = iexp2(this._bits);\n    let ok = false;\n    if (typeof x === 'bigint' && x >= BigInt(0)) {\n      ok = x < max;\n    } else if (Number.isInteger(x) && x >= 0) {\n      const v = BigInt(x);\n      ok = v < max;\n    } else {\n      ok = false;\n    }\n    if (ok) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: bigint | number) {\n    return writeUIntLE(x, this._bits / 8);\n  }\n\n  public encodeType() {\n    const offset = Math.log2(this._bits) - 3;\n    return slebEncode(-5 - offset);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    this.checkType(t);\n    const num = readUIntLE(b, this._bits / 8);\n    if (this._bits <= 32) {\n      return Number(num);\n    } else {\n      return num;\n    }\n  }\n\n  get name() {\n    return `nat${this._bits}`;\n  }\n\n  public valueToString(x: bigint | number) {\n    return x.toString();\n  }\n}\n\n/**\n * Represents an IDL Array\n *\n * Arrays of fixed-sized nat/int type (e.g. nat8), are encoded from and decoded to TypedArrays (e.g. Uint8Array).\n * Arrays of float or other non-primitive types are encoded/decoded as untyped array in Javascript.\n * @param {Type} t\n */\nexport class VecClass<T> extends ConstructType<T[]> {\n  get typeName() {\n    return IdlTypeName.VecClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is VecClass<T> {\n    return instance.typeName === IdlTypeName.VecClass;\n  }\n\n  // If true, this vector is really a blob and we can just use memcpy.\n  //\n  // NOTE:\n  // With support of encoding/dencoding of TypedArrays, this optimization is\n  // only used when plain array of bytes are passed as encoding input in order\n  // to be backward compatible.\n  private _blobOptimization = false;\n\n  constructor(public _type: Type<T>) {\n    super();\n    if (_type instanceof FixedNatClass && _type._bits === 8) {\n      this._blobOptimization = true;\n    }\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVec(this, this._type, d);\n  }\n\n  public covariant(x: any): x is T[] {\n    // Special case for ArrayBuffer\n    const bits =\n      this._type instanceof FixedNatClass\n        ? this._type._bits\n        : this._type instanceof FixedIntClass\n          ? this._type._bits\n          : 0;\n\n    if (\n      (ArrayBuffer.isView(x) && bits == (x as any).BYTES_PER_ELEMENT * 8) ||\n      (Array.isArray(x) &&\n        x.every((v, idx) => {\n          try {\n            return this._type.covariant(v);\n          } catch (e: any) {\n            throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${idx} -> ${e.message}`);\n          }\n        }))\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T[]): Uint8Array {\n    const len = lebEncode(x.length);\n    if (this._blobOptimization) {\n      return concat(len, new Uint8Array(x as unknown as number[]));\n    }\n\n    if (ArrayBuffer.isView(x)) {\n      // Handle TypedArrays with endianness concerns\n      if (x instanceof Int16Array || x instanceof Uint16Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 2));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int16Array) {\n            buffer.setInt16(i * 2, x[i], true); // true = little-endian\n          } else {\n            buffer.setUint16(i * 2, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof Int32Array || x instanceof Uint32Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 4));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof Int32Array) {\n            buffer.setInt32(i * 4, x[i], true);\n          } else {\n            buffer.setUint32(i * 4, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else if (x instanceof BigInt64Array || x instanceof BigUint64Array) {\n        const buffer = new DataView(new ArrayBuffer(x.length * 8));\n        for (let i = 0; i < x.length; i++) {\n          if (x instanceof BigInt64Array) {\n            buffer.setBigInt64(i * 8, x[i], true);\n          } else {\n            buffer.setBigUint64(i * 8, x[i], true);\n          }\n        }\n        return concat(len, new Uint8Array(buffer.buffer));\n      } else {\n        // For Uint8Array, Int8Array, etc. that don't have endianness concerns\n        return concat(len, new Uint8Array(x.buffer, x.byteOffset, x.byteLength));\n      }\n    }\n    const buf = new Pipe(new Uint8Array(len.byteLength + x.length), 0);\n    buf.write(len);\n    for (const d of x) {\n      const encoded = this._type.encodeValue(d);\n      buf.write(new Uint8Array(encoded));\n    }\n    return buf.buffer;\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Vector);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): T[] {\n    const vec = this.checkType(t);\n    if (!(vec instanceof VecClass)) {\n      throw new Error('Not a vector type');\n    }\n    const len = Number(lebDecode(b));\n\n    if (this._type instanceof FixedNatClass) {\n      if (this._type._bits == 8) {\n        return new Uint8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Check if we need to swap bytes for endianness\n        const u16 = new Uint16Array(bytes.buffer, bytes.byteOffset, len);\n        return u16 as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const u32 = new Uint32Array(bytes.buffer, bytes.byteOffset, len);\n        return u32 as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        return new BigUint64Array(b.read(len * 8).buffer) as unknown as T[];\n      }\n    }\n\n    if (this._type instanceof FixedIntClass) {\n      if (this._type._bits == 8) {\n        return new Int8Array(b.read(len)) as unknown as T[];\n      }\n      if (this._type._bits == 16) {\n        const bytes = b.read(len * 2);\n        // Create a DataView to properly handle endianness\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        // Create result array with correct endianness\n        const result = new Int16Array(len);\n        for (let i = 0; i < len; i++) {\n          // Read each value as little-endian (Candid wire format is little-endian)\n          result[i] = view.getInt16(i * 2, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 32) {\n        const bytes = b.read(len * 4);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new Int32Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getInt32(i * 4, true);\n        }\n        return result as unknown as T[];\n      }\n      if (this._type._bits == 64) {\n        const bytes = b.read(len * 8);\n        const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n        const result = new BigInt64Array(len);\n        for (let i = 0; i < len; i++) {\n          result[i] = view.getBigInt64(i * 8, true);\n        }\n        return result as unknown as T[];\n      }\n    }\n\n    const rets: T[] = [];\n    for (let i = 0; i < len; i++) {\n      rets.push(this._type.decodeValue(b, vec._type));\n    }\n    return rets;\n  }\n\n  get name() {\n    return `vec ${this._type.name}`;\n  }\n\n  public display() {\n    return `vec ${this._type.display()}`;\n  }\n\n  public valueToString(x: T[]) {\n    const elements = x.map(e => this._type.valueToString(e));\n    return 'vec {' + elements.join('; ') + '}';\n  }\n}\n\n/**\n * Represents an IDL Option\n * @param {Type} t\n */\nexport class OptClass<T> extends ConstructType<[T] | []> {\n  get typeName() {\n    return IdlTypeName.OptClass;\n  }\n\n  static [Symbol.hasInstance]<T>(instance: any): instance is OptClass<T> {\n    return instance.typeName === IdlTypeName.OptClass;\n  }\n\n  constructor(public _type: Type<T>) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitOpt(this, this._type, d);\n  }\n\n  public covariant(x: any): x is [T] | [] {\n    try {\n      if (Array.isArray(x) && (x.length === 0 || (x.length === 1 && this._type.covariant(x[0]))))\n        return true;\n    } catch (e: any) {\n      throw new Error(\n        `Invalid ${this.display()} argument: ${toReadableString(x)} \\n\\n-> ${e.message}`,\n      );\n    }\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: [T] | []): Uint8Array {\n    if (x.length === 0) {\n      return new Uint8Array([0]);\n    } else {\n      return concat(new Uint8Array([1]), this._type.encodeValue(x[0]));\n    }\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._type.buildTypeTable(typeTable);\n\n    const opCode = slebEncode(IDLTypeIds.Opt);\n    const buffer = this._type.encodeType(typeTable);\n    typeTable.add(this, concat(opCode, buffer));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [T] | [] {\n    if (t instanceof NullClass) {\n      return [];\n    }\n\n    if (t instanceof ReservedClass) {\n      return [];\n    }\n\n    let wireType = t;\n    // unfold wireType, if needed\n    if (t instanceof RecClass) {\n      const ty = t.getType();\n      if (typeof ty === 'undefined') {\n        throw new Error('type mismatch with uninitialized type');\n      } else wireType = ty;\n    }\n\n    if (wireType instanceof OptClass) {\n      switch (safeReadUint8(b)) {\n        case 0:\n          return [];\n        case 1: {\n          // Save the current state of the Pipe `b` to allow rollback in case of an error\n          const checkpoint = b.save();\n          try {\n            // Attempt to decode a value using the `_type` of the current instance\n            const v = this._type.decodeValue(b, wireType._type);\n            return [v];\n          } catch (e: any) {\n            // If an error occurs during decoding, restore the Pipe `b` to its previous state\n            b.restore(checkpoint);\n            // Skip the value at the current wire type to advance the Pipe `b` position\n            wireType._type.decodeValue(b, wireType._type);\n            // Return an empty array to indicate a `none` value\n            return [];\n          }\n        }\n        default:\n          throw new Error('Not an option value');\n      }\n    } else if (\n      // this check corresponds to `not (null <: <t>)` in the spec\n      this._type instanceof NullClass ||\n      this._type instanceof OptClass ||\n      this._type instanceof ReservedClass\n    ) {\n      // null <: <t> :\n      // skip value at wire type (to advance b) and return \"null\", i.e. []\n      wireType.decodeValue(b, wireType);\n      return [];\n    } else {\n      // not (null <: t) :\n      // try constituent type\n      const checkpoint = b.save();\n      try {\n        const v = this._type.decodeValue(b, t);\n        return [v];\n      } catch (e: any) {\n        // decoding failed, but this is opt, so return \"null\", i.e. []\n        b.restore(checkpoint);\n        // skip value at wire type (to advance b)\n        wireType.decodeValue(b, t);\n        // return \"null\"\n        return [];\n      }\n    }\n  }\n\n  get name() {\n    return `opt ${this._type.name}`;\n  }\n\n  public display() {\n    return `opt ${this._type.display()}`;\n  }\n\n  public valueToString(x: [T] | []) {\n    if (x.length === 0) {\n      return 'null';\n    } else {\n      return `opt ${this._type.valueToString(x[0])}`;\n    }\n  }\n}\n\n/**\n * Represents an IDL Record\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class RecordClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.RecordClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is RecordClass {\n    // TupleClass extends RecordClass, so we need to check both here\n    return (\n      instance.typeName === IdlTypeName.RecordClass || instance.typeName === IdlTypeName.TupleClass\n    );\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitRecord(this, this._fields, d);\n  }\n\n  public tryAsTuple(): Type[] | null {\n    const res: Type[] = [];\n    for (let i = 0; i < this._fields.length; i++) {\n      const [key, type] = this._fields[i];\n      if (key !== `_${i}_`) {\n        return null;\n      }\n      res.push(type);\n    }\n    return res;\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      this._fields.every(([k, t]) => {\n        // eslint-disable-next-line\n        if (!x.hasOwnProperty(k)) {\n          throw new Error(`Record is missing key \"${k}\".`);\n        }\n        try {\n          return t.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nfield ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>): Uint8Array {\n    const values = this._fields.map(([key]) => x[key]);\n    const bufs = zipWith(this._fields, values, ([, c], d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, value]) => value.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Record);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(T)),\n    );\n\n    T.add(this, concat(opCode, len, concat(...fields)));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const record = this.checkType(t);\n    if (!(record instanceof RecordClass)) {\n      throw new Error('Not a record type');\n    }\n    const x: Record<string, any> = {};\n\n    let expectedRecordIdx = 0;\n    let actualRecordIdx = 0;\n    while (actualRecordIdx < record._fields.length) {\n      const [hash, type] = record._fields[actualRecordIdx];\n\n      if (expectedRecordIdx >= this._fields.length) {\n        // skip unexpected left over fields present on the wire\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n        continue;\n      }\n\n      const [expectKey, expectType] = this._fields[expectedRecordIdx];\n      const expectedId = idlLabelToId(this._fields[expectedRecordIdx][0]);\n      const actualId = idlLabelToId(hash);\n      if (expectedId === actualId) {\n        // the current field on the wire matches the expected field\n        x[expectKey] = expectType.decodeValue(b, type);\n        expectedRecordIdx++;\n        actualRecordIdx++;\n      } else if (actualId > expectedId) {\n        // The expected field does not exist on the wire\n        if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n          x[expectKey] = [];\n          expectedRecordIdx++;\n        } else {\n          throw new Error('Cannot find required field ' + expectKey);\n        }\n      } else {\n        // The field on the wire does not exist in the output type, so we can skip it\n        type.decodeValue(b, type);\n        actualRecordIdx++;\n      }\n    }\n\n    // initialize left over expected optional fields\n    for (const [expectKey, expectType] of this._fields.slice(expectedRecordIdx)) {\n      if (expectType instanceof OptClass || expectType instanceof ReservedClass) {\n        // TODO this assumes null value in opt is represented as []\n        x[expectKey] = [];\n      } else {\n        throw new Error('Cannot find required field ' + expectKey);\n      }\n    }\n    return x;\n  }\n\n  get fieldsAsObject(): Record<number, Type> {\n    const fields: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      fields[idlLabelToId(name)] = ty;\n    }\n    return fields;\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    const values = this._fields.map(([key]) => x[key]);\n    const fields = zipWith(this._fields, values, ([k, c], d) => k + '=' + c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents Tuple, a syntactic sugar for Record.\n * @param {Type} components\n */\nexport class TupleClass<T extends any[]> extends RecordClass {\n  get typeName() {\n    return IdlTypeName.TupleClass;\n  }\n\n  static [Symbol.hasInstance]<T extends any[]>(instance: any): instance is TupleClass<T> {\n    return instance.typeName === IdlTypeName.TupleClass;\n  }\n\n  protected readonly _components: Type[];\n\n  constructor(_components: Type[]) {\n    const x: Record<string, any> = {};\n    _components.forEach((e, i) => (x['_' + i + '_'] = e));\n    super(x);\n    this._components = _components;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitTuple(this, this._components, d);\n  }\n\n  public covariant(x: any): x is T {\n    // `>=` because tuples can be covariant when encoded.\n\n    if (\n      Array.isArray(x) &&\n      x.length >= this._fields.length &&\n      this._components.every((t, i) => {\n        try {\n          return t.covariant(x[i]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nindex ${i} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: any[]): Uint8Array {\n    const bufs = zipWith(this._components, x, (c, d) => c.encodeValue(d));\n    return concat(...bufs);\n  }\n\n  public decodeValue(b: Pipe, t: Type): T {\n    const tuple = this.checkType(t);\n    if (!(tuple instanceof TupleClass)) {\n      throw new Error('not a tuple type');\n    }\n    if (tuple._components.length < this._components.length) {\n      throw new Error('tuple mismatch');\n    }\n    const res = [];\n    for (const [i, wireType] of tuple._components.entries()) {\n      if (i >= this._components.length) {\n        // skip value\n        wireType.decodeValue(b, wireType);\n      } else {\n        res.push(this._components[i].decodeValue(b, wireType));\n      }\n    }\n    return res as T;\n  }\n\n  public display() {\n    const fields = this._components.map(value => value.display());\n    return `record {${fields.join('; ')}}`;\n  }\n\n  public valueToString(values: any[]) {\n    const fields = zipWith(this._components, values, (c, d) => c.valueToString(d));\n    return `record {${fields.join('; ')}}`;\n  }\n}\n\n/**\n * Represents an IDL Variant\n * @param {object} [fields] - mapping of function name to Type\n */\nexport class VariantClass extends ConstructType<Record<string, any>> {\n  get typeName() {\n    return IdlTypeName.VariantClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is VariantClass {\n    return instance.typeName === IdlTypeName.VariantClass;\n  }\n\n  public readonly _fields: Array<[string, Type]>;\n\n  constructor(fields: Record<string, Type> = {}) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => idlLabelToId(a[0]) - idlLabelToId(b[0]));\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitVariant(this, this._fields, d);\n  }\n\n  public covariant(x: any): x is Record<string, any> {\n    if (\n      typeof x === 'object' &&\n      Object.entries(x).length === 1 &&\n      this._fields.every(([k, v]) => {\n        try {\n          // eslint-disable-next-line\n          return !x.hasOwnProperty(k) || v.covariant(x[k]);\n        } catch (e: any) {\n          throw new Error(`Invalid ${this.display()} argument: \\n\\nvariant ${k} -> ${e.message}`);\n        }\n      })\n    )\n      return true;\n\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: Record<string, any>) {\n    for (let i = 0; i < this._fields.length; i++) {\n      const [name, type] = this._fields[i];\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const idx = lebEncode(i);\n        const buf = type.encodeValue(x[name]);\n\n        return concat(idx, buf);\n      }\n    }\n    throw Error('Variant has no data: ' + x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    this._fields.forEach(([, type]) => {\n      type.buildTypeTable(typeTable);\n    });\n    const opCode = slebEncode(IDLTypeIds.Variant);\n    const len = lebEncode(this._fields.length);\n    const fields = this._fields.map(([key, value]) =>\n      concat(lebEncode(idlLabelToId(key)), value.encodeType(typeTable)),\n    );\n    typeTable.add(this, concat(opCode, len, ...fields));\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    const variant = this.checkType(t);\n    if (!(variant instanceof VariantClass)) {\n      throw new Error('Not a variant type');\n    }\n    const idx = Number(lebDecode(b));\n    if (idx >= variant._fields.length) {\n      throw Error('Invalid variant index: ' + idx);\n    }\n    const [wireHash, wireType] = variant._fields[idx];\n    for (const [key, expectType] of this._fields) {\n      if (idlLabelToId(wireHash) === idlLabelToId(key)) {\n        const value = expectType.decodeValue(b, wireType);\n        return { [key]: value };\n      }\n    }\n    throw new Error('Cannot find field hash ' + wireHash);\n  }\n\n  get name() {\n    const fields = this._fields.map(([key, type]) => key + ':' + type.name);\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public display() {\n    const fields = this._fields.map(\n      ([key, type]) => key + (type.name === 'null' ? '' : `:${type.display()}`),\n    );\n    return `variant {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: Record<string, any>) {\n    for (const [name, type] of this._fields) {\n      // eslint-disable-next-line\n      if (x.hasOwnProperty(name)) {\n        const value = type.valueToString(x[name]);\n        if (value === 'null') {\n          return `variant {${name}}`;\n        } else {\n          return `variant {${name}=${value}}`;\n        }\n      }\n    }\n    throw new Error('Variant has no data: ' + x);\n  }\n\n  get alternativesAsObject(): Record<number, Type> {\n    const alternatives: Record<number, Type> = {};\n    for (const [name, ty] of this._fields) {\n      alternatives[idlLabelToId(name)] = ty;\n    }\n    return alternatives;\n  }\n}\n\n/**\n * Represents a reference to an IDL type, used for defining recursive data\n * types.\n */\nexport class RecClass<T = any> extends ConstructType<T> {\n  get typeName() {\n    return IdlTypeName.RecClass;\n  }\n\n  private static _counter = 0;\n  private _id = RecClass._counter++;\n  private _type: ConstructType<T> | undefined;\n\n  static [Symbol.hasInstance](instance: any): instance is RecClass {\n    return instance.typeName === IdlTypeName.RecClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return v.visitRec(this, this._type, d);\n  }\n\n  public fill(t: ConstructType<T>) {\n    this._type = t;\n  }\n\n  public getType() {\n    return this._type;\n  }\n\n  public covariant(x: any): x is T {\n    if (this._type ? this._type.covariant(x) : false) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.encodeValue(x);\n  }\n\n  public _buildTypeTableImpl(typeTable: TypeTable) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    typeTable.add(this, new Uint8Array([]));\n    this._type.buildTypeTable(typeTable);\n    typeTable.merge(this, this._type.name);\n  }\n\n  public decodeValue(b: Pipe, t: Type) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.decodeValue(b, t);\n  }\n\n  get name() {\n    return `rec_${this._id}`;\n  }\n\n  public display() {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return `${this.name}.${this._type.name}`;\n  }\n\n  public valueToString(x: T) {\n    if (!this._type) {\n      throw Error('Recursive type uninitialized.');\n    }\n    return this._type.valueToString(x);\n  }\n}\n\nfunction decodePrincipalId(b: Pipe): PrincipalId {\n  const x = safeReadUint8(b);\n  if (x !== 1) {\n    throw new Error('Cannot decode principal');\n  }\n\n  const len = Number(lebDecode(b));\n  return PrincipalId.fromUint8Array(new Uint8Array(safeRead(b, len)));\n}\n\n/**\n * Represents an IDL principal reference\n */\nexport class PrincipalClass extends PrimitiveType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.PrincipalClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is PrincipalClass {\n    return instance.typeName === IdlTypeName.PrincipalClass;\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitPrincipal(this, d);\n  }\n\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n  public encodeType(): Uint8Array {\n    return slebEncode(IDLTypeIds.Principal);\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    this.checkType(t);\n    return decodePrincipalId(b);\n  }\n\n  get name() {\n    return 'principal';\n  }\n  public valueToString(x: PrincipalId) {\n    return `${this.name} \"${x.toText()}\"`;\n  }\n}\n\n/**\n * The generic type of the arguments of an {@link Func|IDL Function}.\n */\nexport type GenericIdlFuncArgs = [Type, ...Type[]] | [];\n\n/**\n * The generic type of the return values of an {@link Func|IDL Function}.\n */\nexport type GenericIdlFuncRets = [Type, ...Type[]] | [];\n\n/**\n * Represents an IDL function reference.\n * @param argTypes Argument types.\n * @param retTypes Return types.\n * @param annotations Function annotations.\n */\nexport class FuncClass<\n  Args extends GenericIdlFuncArgs = GenericIdlFuncArgs,\n  Rets extends GenericIdlFuncRets = GenericIdlFuncRets,\n> extends ConstructType<[PrincipalId, string]> {\n  get typeName() {\n    return IdlTypeName.FuncClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is FuncClass {\n    return instance.typeName === IdlTypeName.FuncClass;\n  }\n\n  public static argsToString(types: Type[], v: any[]) {\n    if (types.length !== v.length) {\n      throw new Error('arity mismatch');\n    }\n    return '(' + types.map((t, i) => t.valueToString(v[i])).join(', ') + ')';\n  }\n\n  constructor(\n    public argTypes: Args,\n    public retTypes: Rets,\n    public annotations: string[] = [],\n  ) {\n    super();\n  }\n\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitFunc(this, d);\n  }\n  public covariant(x: any): x is [PrincipalId, string] {\n    if (Array.isArray(x) && x.length === 2 && x[0] && x[0]._isPrincipal && typeof x[1] === 'string')\n      return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue([principal, methodName]: [PrincipalId, string]) {\n    const buf = principal.toUint8Array();\n    const len = lebEncode(buf.byteLength);\n    const canister = concat(new Uint8Array([1]), len, buf);\n\n    const method = new TextEncoder().encode(methodName);\n    const methodLen = lebEncode(method.byteLength);\n    return concat(new Uint8Array([1]), canister, methodLen, method);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this.argTypes.forEach(arg => arg.buildTypeTable(T));\n    this.retTypes.forEach(arg => arg.buildTypeTable(T));\n\n    const opCode = slebEncode(IDLTypeIds.Func);\n    const argLen = lebEncode(this.argTypes.length);\n    const args = concat(...this.argTypes.map(arg => arg.encodeType(T)));\n    const retLen = lebEncode(this.retTypes.length);\n    const rets = concat(...this.retTypes.map(arg => arg.encodeType(T)));\n    const annLen = lebEncode(this.annotations.length);\n    const anns = concat(...this.annotations.map(a => this.encodeAnnotation(a)));\n\n    T.add(this, concat(opCode, argLen, args, retLen, rets, annLen, anns));\n  }\n\n  public decodeValue(b: Pipe, t: Type): [PrincipalId, string] {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode function reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    const x = safeReadUint8(b);\n    if (x !== 1) {\n      throw new Error('Cannot decode function reference');\n    }\n    const canister = decodePrincipalId(b);\n\n    const mLen = Number(lebDecode(b));\n    const buf = safeRead(b, mLen);\n    const decoder = new TextDecoder('utf8', { fatal: true });\n    const method = decoder.decode(buf);\n\n    return [canister, method];\n  }\n\n  get name() {\n    const args = this.argTypes.map(arg => arg.name).join(', ');\n    const rets = this.retTypes.map(arg => arg.name).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args}) -> (${rets})${annon}`;\n  }\n\n  public valueToString([principal, str]: [PrincipalId, string]) {\n    return `func \"${principal.toText()}\".${str}`;\n  }\n\n  public display(): string {\n    const args = this.argTypes.map(arg => arg.display()).join(', ');\n    const rets = this.retTypes.map(arg => arg.display()).join(', ');\n    const annon = ' ' + this.annotations.join(' ');\n    return `(${args})  (${rets})${annon}`;\n  }\n\n  private encodeAnnotation(ann: string): Uint8Array {\n    if (ann === 'query') {\n      return new Uint8Array([1]);\n    } else if (ann === 'oneway') {\n      return new Uint8Array([2]);\n    } else if (ann === 'composite_query') {\n      return new Uint8Array([3]);\n    } else {\n      throw new Error('Illegal function annotation');\n    }\n  }\n}\n\n/**\n * The generic type of the fields of an {@link Service|IDL Service}.\n */\nexport type GenericIdlServiceFields = Record<string, FuncClass>;\n\nexport class ServiceClass<\n  K extends string = string,\n  Fields extends GenericIdlServiceFields = GenericIdlServiceFields,\n> extends ConstructType<PrincipalId> {\n  get typeName() {\n    return IdlTypeName.ServiceClass;\n  }\n\n  static [Symbol.hasInstance](instance: any): instance is ServiceClass {\n    return instance.typeName === IdlTypeName.ServiceClass;\n  }\n\n  public readonly _fields: Array<[K, Fields[K]]>;\n  constructor(fields: Fields) {\n    super();\n    this._fields = Object.entries(fields).sort((a, b) => {\n      if (a[0] < b[0]) {\n        return -1;\n      }\n      if (a[0] > b[0]) {\n        return 1;\n      }\n      return 0;\n    }) as Array<[K, Fields[K]]>;\n  }\n  public accept<D, R>(v: Visitor<D, R>, d: D): R {\n    return v.visitService(this, d);\n  }\n  public covariant(x: any): x is PrincipalId {\n    if (x && x._isPrincipal) return true;\n    throw new Error(`Invalid ${this.display()} argument: ${toReadableString(x)}`);\n  }\n\n  public encodeValue(x: PrincipalId): Uint8Array {\n    const buf = x.toUint8Array();\n    const len = lebEncode(buf.length);\n    return concat(new Uint8Array([1]), len, buf);\n  }\n\n  public _buildTypeTableImpl(T: TypeTable) {\n    this._fields.forEach(([_, func]) => func.buildTypeTable(T));\n    const opCode = slebEncode(IDLTypeIds.Service);\n    const len = lebEncode(this._fields.length);\n    const meths = this._fields.map(([label, func]) => {\n      const labelBuf = new TextEncoder().encode(label);\n      const labelLen = lebEncode(labelBuf.length);\n      return concat(labelLen, labelBuf, func.encodeType(T));\n    });\n\n    T.add(this, concat(opCode, len, ...meths));\n  }\n\n  public decodeValue(b: Pipe, t: Type): PrincipalId {\n    const tt = t instanceof RecClass ? (t.getType() ?? t) : t;\n    if (!subtype(tt, this)) {\n      throw new Error(\n        `Cannot decode service reference at type ${this.display()} from wire type ${tt.display()}`,\n      );\n    }\n    return decodePrincipalId(b);\n  }\n  get name() {\n    const fields = this._fields.map(([key, value]) => key + ':' + value.name);\n    return `service {${fields.join('; ')}}`;\n  }\n\n  public valueToString(x: PrincipalId) {\n    return `service \"${x.toText()}\"`;\n  }\n\n  public fieldsAsObject(): Fields {\n    const fields = {} as Fields;\n    for (const [name, ty] of this._fields) {\n      fields[name] = ty;\n    }\n    return fields;\n  }\n}\n\n/**\n * Takes an unknown value and returns a string representation of it.\n * @param x - unknown value\n * @returns {string} string representation of the value\n */\nfunction toReadableString(x: unknown): string {\n  const str = JSON.stringify(x, (_key, value) =>\n    typeof value === 'bigint' ? `BigInt(${value})` : value,\n  );\n\n  return str && str.length > toReadableString_max\n    ? str.substring(0, toReadableString_max - 3) + '...'\n    : str;\n}\n\n/**\n * Encode a array of values\n * @param argTypes - array of Types\n * @param args - array of values\n * @returns {Uint8Array} serialised value\n */\nexport function encode(argTypes: Array<Type<any>>, args: any[]): Uint8Array {\n  if (args.length < argTypes.length) {\n    throw Error('Wrong number of message arguments');\n  }\n\n  const typeTable = new TypeTable();\n  argTypes.forEach(t => t.buildTypeTable(typeTable));\n\n  const magic = new TextEncoder().encode(magicNumber);\n  const table = typeTable.encode();\n  const len = lebEncode(args.length);\n  const typs = concat(...argTypes.map(t => t.encodeType(typeTable)));\n  const vals = concat(\n    ...zipWith(argTypes, args, (t, x) => {\n      try {\n        t.covariant(x);\n      } catch (e: any) {\n        const err = new Error(e.message + '\\n\\n');\n        throw err;\n      }\n\n      return t.encodeValue(x);\n    }),\n  );\n\n  return concat(magic, table, len, typs, vals);\n}\n\n/**\n * Decode a binary value\n * @param retTypes - Types expected in the buffer.\n * @param bytes - hex-encoded string, or buffer.\n * @returns Value deserialised to JS type\n */\nexport function decode(retTypes: Type[], bytes: Uint8Array): JsonValue[] {\n  const b = new Pipe(bytes);\n\n  if (bytes.byteLength < magicNumber.length) {\n    throw new Error('Message length smaller than magic number');\n  }\n  const magicBuffer = safeRead(b, magicNumber.length);\n  const magic = new TextDecoder().decode(magicBuffer);\n  if (magic !== magicNumber) {\n    throw new Error('Wrong magic number: ' + JSON.stringify(magic));\n  }\n\n  function readTypeTable(pipe: Pipe): [Array<[IDLTypeIds, any]>, number[]] {\n    const typeTable: Array<[IDLTypeIds, any]> = [];\n    const len = Number(lebDecode(pipe));\n\n    for (let i = 0; i < len; i++) {\n      const ty = Number(slebDecode(pipe));\n      switch (ty) {\n        case IDLTypeIds.Opt:\n        case IDLTypeIds.Vector: {\n          const t = Number(slebDecode(pipe));\n          typeTable.push([ty, t]);\n          break;\n        }\n        case IDLTypeIds.Record:\n        case IDLTypeIds.Variant: {\n          const fields = [];\n          let objectLength = Number(lebDecode(pipe));\n          let prevHash;\n          while (objectLength--) {\n            const hash = Number(lebDecode(pipe));\n            if (hash >= Math.pow(2, 32)) {\n              throw new Error('field id out of 32-bit range');\n            }\n            if (typeof prevHash === 'number' && prevHash >= hash) {\n              throw new Error('field id collision or not sorted');\n            }\n            prevHash = hash;\n            const t = Number(slebDecode(pipe));\n            fields.push([hash, t]);\n          }\n          typeTable.push([ty, fields]);\n          break;\n        }\n        case IDLTypeIds.Func: {\n          const args = [];\n          let argLength = Number(lebDecode(pipe));\n          while (argLength--) {\n            args.push(Number(slebDecode(pipe)));\n          }\n          const returnValues = [];\n          let returnValuesLength = Number(lebDecode(pipe));\n          while (returnValuesLength--) {\n            returnValues.push(Number(slebDecode(pipe)));\n          }\n          const annotations = [];\n          let annotationLength = Number(lebDecode(pipe));\n          while (annotationLength--) {\n            const annotation = Number(lebDecode(pipe));\n            switch (annotation) {\n              case 1: {\n                annotations.push('query');\n                break;\n              }\n              case 2: {\n                annotations.push('oneway');\n                break;\n              }\n              case 3: {\n                annotations.push('composite_query');\n                break;\n              }\n              default:\n                throw new Error('unknown annotation');\n            }\n          }\n          typeTable.push([ty, [args, returnValues, annotations]]);\n          break;\n        }\n        case IDLTypeIds.Service: {\n          let servLength = Number(lebDecode(pipe));\n          const methods = [];\n          while (servLength--) {\n            const nameLength = Number(lebDecode(pipe));\n            const funcName = new TextDecoder().decode(safeRead(pipe, nameLength));\n            const funcType = slebDecode(pipe);\n            methods.push([funcName, funcType]);\n          }\n          typeTable.push([ty, methods]);\n          break;\n        }\n        default:\n          throw new Error('Illegal op_code: ' + ty);\n      }\n    }\n\n    const rawList: number[] = [];\n    const length = Number(lebDecode(pipe));\n    for (let i = 0; i < length; i++) {\n      rawList.push(Number(slebDecode(pipe)));\n    }\n    return [typeTable, rawList];\n  }\n  const [rawTable, rawTypes] = readTypeTable(b);\n  if (rawTypes.length < retTypes.length) {\n    throw new Error('Wrong number of return values');\n  }\n\n  const table: RecClass[] = rawTable.map(_ => Rec());\n  function getType(t: number): Type {\n    if (t < -24) {\n      throw new Error('future value not supported');\n    }\n    if (t < 0) {\n      switch (t) {\n        case -1:\n          return Null;\n        case -2:\n          return Bool;\n        case -3:\n          return Nat;\n        case -4:\n          return Int;\n        case -5:\n          return Nat8;\n        case -6:\n          return Nat16;\n        case -7:\n          return Nat32;\n        case -8:\n          return Nat64;\n        case -9:\n          return Int8;\n        case -10:\n          return Int16;\n        case -11:\n          return Int32;\n        case -12:\n          return Int64;\n        case -13:\n          return Float32;\n        case -14:\n          return Float64;\n        case -15:\n          return Text;\n        case -16:\n          return Reserved;\n        case -17:\n          return Empty;\n        case -24:\n          return Principal;\n        default:\n          throw new Error('Illegal op_code: ' + t);\n      }\n    }\n    if (t >= rawTable.length) {\n      throw new Error('type index out of range');\n    }\n    return table[t];\n  }\n  function buildType(entry: [IDLTypeIds, any]): Type {\n    switch (entry[0]) {\n      case IDLTypeIds.Vector: {\n        const ty = getType(entry[1]);\n        return Vec(ty);\n      }\n      case IDLTypeIds.Opt: {\n        const ty = getType(entry[1]);\n        return Opt(ty);\n      }\n      case IDLTypeIds.Record: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        const record = Record(fields);\n        const tuple = record.tryAsTuple();\n        if (Array.isArray(tuple)) {\n          return Tuple(...tuple);\n        } else {\n          return record;\n        }\n      }\n      case IDLTypeIds.Variant: {\n        const fields: Record<string, Type> = {};\n        for (const [hash, ty] of entry[1]) {\n          const name = `_${hash}_`;\n          fields[name] = getType(ty);\n        }\n        return Variant(fields);\n      }\n      case IDLTypeIds.Func: {\n        const [args, returnValues, annotations] = entry[1];\n        return Func(\n          args.map((t: number) => getType(t)),\n          returnValues.map((t: number) => getType(t)),\n          annotations,\n        );\n      }\n      case IDLTypeIds.Service: {\n        const rec: Record<string, FuncClass> = {};\n        const methods = entry[1] as [[string, number]];\n        for (const [name, typeRef] of methods) {\n          let type: Type | undefined = getType(typeRef);\n\n          if (type instanceof RecClass) {\n            // unpack reference type\n            type = type.getType();\n          }\n          if (!(type instanceof FuncClass)) {\n            throw new Error('Illegal service definition: services can only contain functions');\n          }\n          rec[name] = type;\n        }\n        return Service(rec);\n      }\n      default:\n        throw new Error('Illegal op_code: ' + entry[0]);\n    }\n  }\n\n  rawTable.forEach((entry, i) => {\n    // Process function type first, so that we can construct the correct service type\n    if (entry[0] === IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n  rawTable.forEach((entry, i) => {\n    if (entry[0] !== IDLTypeIds.Func) {\n      const t = buildType(entry);\n      table[i].fill(t);\n    }\n  });\n\n  resetSubtypeCache();\n  const types = rawTypes.map(t => getType(t));\n  try {\n    const output = retTypes.map((t, i) => {\n      return t.decodeValue(b, types[i]);\n    });\n\n    // skip unused values\n    for (let ind = retTypes.length; ind < types.length; ind++) {\n      types[ind].decodeValue(b, types[ind]);\n    }\n\n    if (b.byteLength > 0) {\n      throw new Error('decode: Left-over bytes');\n    }\n\n    return output;\n  } finally {\n    resetSubtypeCache();\n  }\n}\n\n/**\n * An Interface Factory, normally provided by a Candid code generation.\n */\nexport type InterfaceFactory = (idl: {\n  IDL: {\n    Empty: EmptyClass;\n    Reserved: ReservedClass;\n    Unknown: UnknownClass;\n    Bool: BoolClass;\n    Null: NullClass;\n    Text: TextClass;\n    Int: IntClass;\n    Nat: NatClass;\n\n    Float32: FloatClass;\n    Float64: FloatClass;\n\n    Int8: FixedIntClass;\n    Int16: FixedIntClass;\n    Int32: FixedIntClass;\n    Int64: FixedIntClass;\n\n    Nat8: FixedNatClass;\n    Nat16: FixedNatClass;\n    Nat32: FixedNatClass;\n    Nat64: FixedNatClass;\n\n    Principal: PrincipalClass;\n\n    Tuple: typeof Tuple;\n    Vec: typeof Vec;\n    Opt: typeof Opt;\n    Record: typeof Record;\n    Variant: typeof Variant;\n    Rec: typeof Rec;\n    Func: typeof Func;\n\n    Service(t: Record<string, FuncClass>): ServiceClass;\n  };\n}) => ServiceClass;\n\n// Export Types instances.\nexport const Empty = new EmptyClass();\nexport const Reserved = new ReservedClass();\n/**\n * Client-only type for deserializing unknown data. Not supported by Candid, and its use is discouraged.\n */\nexport const Unknown = new UnknownClass();\nexport const Bool = new BoolClass();\nexport const Null = new NullClass();\nexport const Text = new TextClass();\nexport const Int = new IntClass();\nexport const Nat = new NatClass();\n\nexport const Float32 = new FloatClass(32);\nexport const Float64 = new FloatClass(64);\n\nexport const Int8 = new FixedIntClass(8);\nexport const Int16 = new FixedIntClass(16);\nexport const Int32 = new FixedIntClass(32);\nexport const Int64 = new FixedIntClass(64);\n\nexport const Nat8 = new FixedNatClass(8);\nexport const Nat16 = new FixedNatClass(16);\nexport const Nat32 = new FixedNatClass(32);\nexport const Nat64 = new FixedNatClass(64);\n\nexport const Principal = new PrincipalClass();\n\n/**\n *\n * @param types array of any types\n * @returns TupleClass from those types\n */\nexport function Tuple<T extends any[]>(...types: T): TupleClass<T> {\n  return new TupleClass(types);\n}\n/**\n *\n * @param t IDL Type\n * @returns VecClass from that type\n */\nexport function Vec<T>(t: Type<T>): VecClass<T> {\n  return new VecClass(t);\n}\n/**\n *\n * @param t IDL Type\n * @returns OptClass of Type\n */\nexport function Opt<T>(t: Type<T>): OptClass<T> {\n  return new OptClass(t);\n}\n/**\n *\n * @param t Record of string and IDL Type\n * @returns RecordClass of string and Type\n */\nexport function Record(t: Record<string, Type>): RecordClass {\n  return new RecordClass(t);\n}\n\n/**\n *\n * @param fields Record of string and IDL Type\n * @returns VariantClass\n */\nexport function Variant(fields: Record<string, Type>): VariantClass {\n  return new VariantClass(fields);\n}\n/**\n *\n * @returns new RecClass\n */\nexport function Rec(): RecClass {\n  return new RecClass();\n}\n\n/**\n *\n * @param args array of IDL Types\n * @param ret array of IDL Types\n * @param annotations array of strings, [] by default\n * @returns new FuncClass\n */\nexport function Func<\n  Args extends GenericIdlFuncArgs = GenericIdlFuncArgs,\n  Ret extends GenericIdlFuncRets = GenericIdlFuncRets,\n>(args: Args, ret: Ret, annotations: string[] = []): FuncClass<Args, Ret> {\n  return new FuncClass(args, ret, annotations);\n}\n\n/**\n *\n * @param t Record of string and FuncClass\n * @returns ServiceClass\n */\nexport function Service<\n  K extends string = string,\n  Fields extends GenericIdlServiceFields = GenericIdlServiceFields,\n>(t: Fields): ServiceClass<K, Fields> {\n  return new ServiceClass(t);\n}\n\n/**\n * The list of relations between types we assume to hold. Uses the types .name property as key\n */\nclass Relations {\n  private rels: Map<string, Map<string, boolean>>;\n\n  constructor(relations = new Map()) {\n    this.rels = relations;\n  }\n\n  copy(): Relations {\n    const copy = new Map();\n    for (const [key, value] of this.rels.entries()) {\n      const valCopy = new Map(value);\n      copy.set(key, valCopy);\n    }\n    return new Relations(copy);\n  }\n\n  /// Returns whether we know for sure that a relation holds or doesn't (`true` or `false`), or\n  /// if we don't know yet (`undefined`)\n  known(t1: Type, t2: Type): boolean | undefined {\n    return this.rels.get(t1.name)?.get(t2.name);\n  }\n\n  addNegative(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, false);\n  }\n\n  add(t1: Type, t2: Type) {\n    this.addNames(t1.name, t2.name, true);\n  }\n\n  display(): string {\n    let result = '';\n    for (const [t1, v] of this.rels) {\n      for (const [t2, known] of v) {\n        const subty = known ? ':<' : '!<:';\n        result += `${t1} ${subty} ${t2}\\n`;\n      }\n    }\n    return result;\n  }\n\n  private addNames(t1: string, t2: string, isSubtype: boolean) {\n    const t1Map = this.rels.get(t1);\n    if (t1Map == undefined) {\n      const newMap = new Map();\n      newMap.set(t2, isSubtype);\n      this.rels.set(t1, newMap);\n    } else {\n      t1Map.set(t2, isSubtype);\n    }\n  }\n}\n\n/// `subtypeCache` holds subtyping relations we've previously computed while decoding a message\nlet subtypeCache: Relations = new Relations();\n\n/** Resets the global subtyping cache */\nexport function resetSubtypeCache() {\n  subtypeCache = new Relations();\n}\n\nfunction eqFunctionAnnotations(t1: FuncClass, t2: FuncClass): boolean {\n  const t1Annotations = new Set(t1.annotations);\n  const t2Annotations = new Set(t2.annotations);\n  if (t1Annotations.size !== t2Annotations.size) {\n    return false;\n  }\n  for (const a of t1Annotations) {\n    if (!t2Annotations.has(a)) return false;\n  }\n  return true;\n}\n\nfunction canBeOmmitted(t: Type) {\n  return t instanceof OptClass || t instanceof NullClass || t instanceof ReservedClass;\n}\n\n/**\n * Subtyping on Candid types t1 <: t2 (Exported for testing)\n * @param t1 The potential subtype\n * @param t2 The potential supertype\n */\nexport function subtype(t1: Type, t2: Type): boolean {\n  const relations = subtypeCache.copy();\n  const isSubtype = subtype_(relations, t1, t2);\n  if (isSubtype) {\n    subtypeCache.add(t1, t2);\n  } else {\n    subtypeCache.addNegative(t1, t2);\n  }\n  return isSubtype;\n}\n\nfunction subtype_(relations: Relations, t1: Type, t2: Type): boolean {\n  if (t1.name === t2.name) return true;\n  const known = relations.known(t1, t2);\n  if (known !== undefined) return known;\n  relations.add(t1, t2);\n\n  if (t2 instanceof ReservedClass) return true;\n  if (t1 instanceof EmptyClass) return true;\n  if (t1 instanceof NatClass && t2 instanceof IntClass) return true;\n  if (t1 instanceof VecClass && t2 instanceof VecClass)\n    return subtype_(relations, t1._type, t2._type);\n  if (t2 instanceof OptClass) return true;\n  if (t1 instanceof RecordClass && t2 instanceof RecordClass) {\n    const t1Object = t1.fieldsAsObject;\n    for (const [label, ty2] of t2._fields) {\n      const ty1 = t1Object[idlLabelToId(label)];\n      if (!ty1) {\n        if (!canBeOmmitted(ty2)) return false;\n      } else {\n        if (!subtype_(relations, ty1, ty2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof FuncClass && t2 instanceof FuncClass) {\n    if (!eqFunctionAnnotations(t1, t2)) return false;\n    for (let i = 0; i < t1.argTypes.length; i++) {\n      const argTy1 = t1.argTypes[i];\n      if (i < t2.argTypes.length) {\n        if (!subtype_(relations, t2.argTypes[i], argTy1)) return false;\n      } else {\n        if (!canBeOmmitted(argTy1)) return false;\n      }\n    }\n    for (let i = 0; i < t2.retTypes.length; i++) {\n      const retTy2 = t2.retTypes[i];\n      if (i < t1.retTypes.length) {\n        if (!subtype_(relations, t1.retTypes[i], retTy2)) return false;\n      } else {\n        if (!canBeOmmitted(retTy2)) return false;\n      }\n    }\n    return true;\n  }\n\n  if (t1 instanceof VariantClass && t2 instanceof VariantClass) {\n    const t2Object = t2.alternativesAsObject;\n    for (const [label, ty1] of t1._fields) {\n      const ty2 = t2Object[idlLabelToId(label)];\n      if (!ty2) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof ServiceClass && t2 instanceof ServiceClass) {\n    const t1Object = t1.fieldsAsObject();\n    for (const [name, ty2] of t2._fields) {\n      const ty1 = t1Object[name];\n      if (!ty1) return false;\n      if (!subtype_(relations, ty1, ty2)) return false;\n    }\n    return true;\n  }\n\n  if (t1 instanceof RecClass) {\n    return subtype_(relations, t1.getType()!, t2);\n  }\n  if (t2 instanceof RecClass) {\n    return subtype_(relations, t1, t2.getType()!);\n  }\n  return false;\n}\n", "/**\n * Concatenate multiple Uint8Arrays.\n * @param uint8Arrays The Uint8Arrays to concatenate.\n */\nexport function concat(...uint8Arrays: Uint8Array[]): Uint8Array {\n  const result = new Uint8Array(uint8Arrays.reduce((acc, curr) => acc + curr.byteLength, 0));\n  let index = 0;\n  for (const b of uint8Arrays) {\n    result.set(b, index);\n    index += b.byteLength;\n  }\n  return result;\n}\n\n/**\n * A class that abstracts a pipe-like Uint8Array.\n */\nexport class PipeArrayBuffer {\n  /**\n   * The reading view. It's a sliding window as we read and write, pointing to the buffer.\n   * @private\n   */\n  private _view: Uint8Array;\n\n  /**\n   * Save a checkpoint of the reading view (for backtracking)\n   */\n  public save(): Uint8Array {\n    return this._view;\n  }\n\n  /**\n   * Restore a checkpoint of the reading view (for backtracking)\n   * @param checkPoint a previously saved checkpoint\n   */\n  public restore(checkPoint: Uint8Array) {\n    if (!(checkPoint instanceof Uint8Array)) {\n      throw new Error('Checkpoint must be a Uint8Array');\n    }\n    this._view = checkPoint;\n  }\n\n  /**\n   * The actual buffer containing the bytes.\n   * @private\n   */\n  private _buffer: Uint8Array;\n\n  /**\n   * Creates a new instance of a pipe\n   * @param buffer an optional buffer to start with\n   * @param length an optional amount of bytes to use for the length.\n   */\n  constructor(buffer?: Uint8Array, length = buffer?.byteLength || 0) {\n    if (buffer && !(buffer instanceof Uint8Array)) {\n      try {\n        buffer = uint8FromBufLike(buffer);\n      } catch {\n        throw new Error('Buffer must be a Uint8Array');\n      }\n    }\n    if (length < 0 || !Number.isInteger(length)) {\n      throw new Error('Length must be a non-negative integer');\n    }\n    if (buffer && length > buffer.byteLength) {\n      throw new Error('Length cannot exceed buffer length');\n    }\n    this._buffer = buffer || new Uint8Array(0);\n    this._view = new Uint8Array(this._buffer.buffer, 0, length);\n  }\n\n  get buffer(): Uint8Array {\n    // Return a copy of the buffer.\n    return this._view.slice();\n  }\n\n  get byteLength(): number {\n    return this._view.byteLength;\n  }\n\n  /**\n   * Read `num` number of bytes from the front of the pipe.\n   * @param num The number of bytes to read.\n   */\n  public read(num: number): Uint8Array {\n    const result = this._view.subarray(0, num);\n    this._view = this._view.subarray(num);\n    return result.slice();\n  }\n\n  public readUint8(): number | undefined {\n    if (this._view.byteLength === 0) {\n      return undefined;\n    }\n    const result = this._view[0];\n    this._view = this._view.subarray(1);\n    return result;\n  }\n\n  /**\n   * Write a buffer to the end of the pipe.\n   * @param buf The bytes to write.\n   */\n  public write(buf: Uint8Array): void {\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error('Buffer must be a Uint8Array');\n    }\n    const offset = this._view.byteLength;\n    if (this._view.byteOffset + this._view.byteLength + buf.byteLength >= this._buffer.byteLength) {\n      // Alloc grow the view to include the new bytes.\n      this.alloc(buf.byteLength);\n    } else {\n      // Update the view to include the new bytes.\n      this._view = new Uint8Array(\n        this._buffer.buffer,\n        this._view.byteOffset,\n        this._view.byteLength + buf.byteLength,\n      );\n    }\n\n    this._view.set(buf, offset);\n  }\n\n  /**\n   * Whether or not there is more data to read from the buffer\n   */\n  public get end(): boolean {\n    return this._view.byteLength === 0;\n  }\n\n  /**\n   * Allocate a fixed amount of memory in the buffer. This does not affect the view.\n   * @param amount A number of bytes to add to the buffer.\n   */\n  public alloc(amount: number) {\n    if (amount <= 0 || !Number.isInteger(amount)) {\n      throw new Error('Amount must be a positive integer');\n    }\n    // Add a little bit of exponential growth.\n    const b = new Uint8Array(((this._buffer.byteLength + amount) * 1.2) | 0);\n    const v = new Uint8Array(b.buffer, 0, this._view.byteLength + amount);\n    v.set(this._view);\n    this._buffer = b;\n    this._view = v;\n  }\n}\n\n/**\n * Returns a true Uint8Array from an ArrayBufferLike object.\n * @param bufLike a buffer-like object\n * @returns Uint8Array\n */\nexport function uint8FromBufLike(\n  bufLike:\n    | ArrayBuffer\n    | Uint8Array\n    | DataView\n    | ArrayBufferView\n    | ArrayBufferLike\n    | [number]\n    | number[]\n    | { buffer: ArrayBuffer },\n): Uint8Array {\n  if (!bufLike) {\n    throw new Error('Input cannot be null or undefined');\n  }\n\n  if (bufLike instanceof Uint8Array) {\n    return bufLike;\n  }\n  if (bufLike instanceof ArrayBuffer) {\n    return new Uint8Array(bufLike);\n  }\n  if (Array.isArray(bufLike)) {\n    return new Uint8Array(bufLike);\n  }\n  if ('buffer' in bufLike) {\n    return uint8FromBufLike(bufLike.buffer);\n  }\n  return new Uint8Array(bufLike);\n}\n\n/**\n *\n * @param u1 uint8Array 1\n * @param u2 uint8Array 2\n * @returns number - negative if u1 < u2, positive if u1 > u2, 0 if u1 === u2\n */\nexport function compare(u1: Uint8Array, u2: Uint8Array): number {\n  if (u1.byteLength !== u2.byteLength) {\n    return u1.byteLength - u2.byteLength;\n  }\n  for (let i = 0; i < u1.length; i++) {\n    if (u1[i] !== u2[i]) {\n      return u1[i] - u2[i];\n    }\n  }\n  return 0;\n}\n\n/**\n * Checks two uint8Arrays for equality.\n * @param u1 uint8Array 1\n * @param u2 uint8Array 2\n * @returns boolean\n */\nexport function uint8Equals(u1: Uint8Array, u2: Uint8Array): boolean {\n  return compare(u1, u2) === 0;\n}\n\n/**\n * Helpers to convert a Uint8Array to a DataView.\n * @param uint8 Uint8Array\n * @returns DataView\n */\nexport function uint8ToDataView(uint8: Uint8Array): DataView {\n  if (!(uint8 instanceof Uint8Array)) {\n    throw new Error('Input must be a Uint8Array');\n  }\n  return new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n}\n", "/**\n * Hashes a string to a number. Algorithm can be found here:\n * https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf\n * @param s - string to hash\n * @returns number representing hashed string\n */\nfunction idlHash(s: string): number {\n  const utf8encoder = new TextEncoder();\n  const array = utf8encoder.encode(s);\n\n  let h = 0;\n  for (const c of array) {\n    h = (h * 223 + c) % 2 ** 32;\n  }\n  return h;\n}\n\n/**\n *\n * @param label string\n * @returns number representing hashed label\n */\nexport function idlLabelToId(label: string): number {\n  if (/^_\\d+_$/.test(label) || /^_0x[0-9a-fA-F]+_$/.test(label)) {\n    const num = +label.slice(1, -1);\n    if (Number.isSafeInteger(num) && num >= 0 && num < 2 ** 32) {\n      return num;\n    }\n  }\n  return idlHash(label);\n}\n", "// Note: this file uses buffer-pipe, which on Node only, uses the Node Buffer\n//       implementation, which isn't compatible with the NPM buffer package\n//       which we use everywhere else. This means that we have to transform\n//       one into the other, hence why every function that returns a Buffer\n//       actually return `new Buffer(pipe.buffer)`.\n// TODO: The best solution would be to have our own buffer type around\n//       Uint8Array which is standard.\nimport { PipeArrayBuffer as Pipe } from './buffer.ts';\nimport { ilog2 } from './bigint-math.ts';\n\nfunction eob(): never {\n  throw new Error('unexpected end of buffer');\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param num number\n * @returns Uint8Array\n */\nexport function safeRead(pipe: Pipe, num: number): Uint8Array {\n  if (pipe.byteLength < num) {\n    eob();\n  }\n  return pipe.read(num);\n}\n\n/**\n * @param pipe - PipeArrayBuffer simulating buffer-pipe api\n */\nexport function safeReadUint8(pipe: Pipe): number {\n  const byte = pipe.readUint8();\n  if (byte === undefined) {\n    eob();\n  }\n  return byte;\n}\n\n/**\n * Encode a positive number (or bigint) into a Buffer. The number will be floored to the\n * nearest integer.\n * @param value The number to encode.\n */\nexport function lebEncode(value: bigint | number): Uint8Array {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  if (value < BigInt(0)) {\n    throw new Error('Cannot leb encode negative values.');\n  }\n\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = Number(value & BigInt(0x7f));\n    value /= BigInt(0x80);\n    if (value === BigInt(0)) {\n      pipe.write(new Uint8Array([i]));\n      break;\n    } else {\n      pipe.write(new Uint8Array([i | 0x80]));\n    }\n  }\n\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number will always be positive (does not\n * support signed leb encoding).\n * @param pipe A Buffer containing the leb encoded bits.\n */\nexport function lebDecode(pipe: Pipe): bigint {\n  let weight = BigInt(1);\n  let value = BigInt(0);\n  let byte;\n\n  do {\n    byte = safeReadUint8(pipe);\n    value += BigInt(byte & 0x7f).valueOf() * weight;\n    weight *= BigInt(128);\n  } while (byte >= 0x80);\n\n  return value;\n}\n\n/**\n * Encode a number (or bigint) into a Buffer, with support for negative numbers. The number\n * will be floored to the nearest integer.\n * @param value The number to encode.\n */\nexport function slebEncode(value: bigint | number): Uint8Array {\n  if (typeof value === 'number') {\n    value = BigInt(value);\n  }\n\n  const isNeg = value < BigInt(0);\n  if (isNeg) {\n    value = -value - BigInt(1);\n  }\n  const byteLength = (value === BigInt(0) ? 0 : ilog2(value)) + 1;\n  const pipe = new Pipe(new Uint8Array(byteLength), 0);\n  while (true) {\n    const i = getLowerBytes(value);\n    value /= BigInt(0x80);\n\n    // prettier-ignore\n    if (   ( isNeg && value === BigInt(0) && (i & 0x40) !== 0)\n          || (!isNeg && value === BigInt(0) && (i & 0x40) === 0)) {\n        pipe.write(new Uint8Array([i]));\n        break;\n      } else {\n        pipe.write(new Uint8Array([i | 0x80]));\n      }\n  }\n\n  function getLowerBytes(num: bigint): number {\n    const bytes = num % BigInt(0x80);\n    if (isNeg) {\n      // We swap the bits here again, and remove 1 to do two's complement.\n      return Number(BigInt(0x80) - bytes - BigInt(1));\n    } else {\n      return Number(bytes);\n    }\n  }\n  return pipe.buffer;\n}\n\n/**\n * Decode a leb encoded buffer into a bigint. The number is decoded with support for negative\n * signed-leb encoding.\n * @param pipe A Buffer containing the signed leb encoded bits.\n */\nexport function slebDecode(pipe: Pipe): bigint {\n  // Get the size of the buffer, then cut a buffer of that size.\n  const pipeView = new Uint8Array(pipe.buffer);\n  let len = 0;\n  for (; len < pipeView.byteLength; len++) {\n    if (pipeView[len] < 0x80) {\n      // If it's a positive number, we reuse lebDecode.\n      if ((pipeView[len] & 0x40) === 0) {\n        return lebDecode(pipe);\n      }\n      break;\n    }\n  }\n\n  const bytes = new Uint8Array(safeRead(pipe, len + 1));\n  let value = BigInt(0);\n  for (let i = bytes.byteLength - 1; i >= 0; i--) {\n    value = value * BigInt(0x80) + BigInt(0x80 - (bytes[i] & 0x7f) - 1);\n  }\n  return -value - BigInt(1);\n}\n\n/**\n *\n * @param value bigint or number\n * @param byteLength number\n * @returns Uint8Array\n */\nexport function writeUIntLE(value: bigint | number, byteLength: number): Uint8Array {\n  if (BigInt(value) < BigInt(0)) {\n    throw new Error('Cannot write negative values.');\n  }\n  return writeIntLE(value, byteLength);\n}\n\n/**\n *\n * @param value - bigint or number\n * @param byteLength - number\n * @returns Uint8Array\n */\nexport function writeIntLE(value: bigint | number, byteLength: number): Uint8Array {\n  value = BigInt(value);\n\n  const pipe = new Pipe(new Uint8Array(Math.min(1, byteLength)), 0);\n  let i = 0;\n  let mul = BigInt(256);\n  let sub = BigInt(0);\n  let byte = Number(value % mul);\n  pipe.write(new Uint8Array([byte]));\n  while (++i < byteLength) {\n    if (value < 0 && sub === BigInt(0) && byte !== 0) {\n      sub = BigInt(1);\n    }\n    byte = Number((value / mul - sub) % BigInt(256));\n    pipe.write(new Uint8Array([byte]));\n    mul *= BigInt(256);\n  }\n\n  return pipe.buffer;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readUIntLE(pipe: Pipe, byteLength: number): bigint {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = BigInt(safeReadUint8(pipe));\n  let mul = BigInt(1);\n  let i = 0;\n  while (++i < byteLength) {\n    mul *= BigInt(256);\n    const byte = BigInt(safeReadUint8(pipe));\n    val = val + mul * byte;\n  }\n  return val;\n}\n\n/**\n *\n * @param pipe Pipe from buffer-pipe\n * @param byteLength number\n * @returns bigint\n */\nexport function readIntLE(pipe: Pipe, byteLength: number): bigint {\n  if (byteLength <= 0 || !Number.isInteger(byteLength)) {\n    throw new Error('Byte length must be a positive integer');\n  }\n  let val = readUIntLE(pipe, byteLength);\n  const mul = BigInt(2) ** (BigInt(8) * BigInt(byteLength - 1) + BigInt(7));\n  if (val >= mul) {\n    val -= mul * BigInt(2);\n  }\n  return val;\n}\n", "/**\n * Equivalent to `Math.log2(n)` with support for `BigInt` values\n * @param n bigint or integer\n * @returns integer\n */\nexport function ilog2(n: bigint | number): number {\n  const nBig = BigInt(n);\n  if (n <= 0) {\n    throw new RangeError('Input must be positive');\n  }\n  return nBig.toString(2).length - 1;\n}\n\n/**\n * Equivalent to `2 ** n` with support for `BigInt` values\n * (necessary for browser preprocessors which replace the `**` operator with `Math.pow`)\n * @param n bigint or integer\n * @returns bigint\n */\nexport function iexp2(n: bigint | number): bigint {\n  const nBig = BigInt(n);\n  if (n < 0) {\n    throw new RangeError('Input must be non-negative');\n  }\n  return BigInt(1) << nBig;\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as IDL from './idl.ts';\n\nexport interface ParseConfig {\n  random?: boolean;\n}\n\nexport interface UIConfig {\n  input?: HTMLElement;\n  form?: InputForm;\n  parse(t: IDL.Type, config: ParseConfig, v: string): any;\n}\n\nexport interface FormConfig {\n  open?: HTMLElement;\n  event?: string;\n  labelMap?: Record<string, string>;\n  container?: HTMLElement;\n  render(t: IDL.Type): InputBox;\n}\n\nexport class InputBox {\n  public status: HTMLElement;\n  public label: string | null = null;\n  public value: any = undefined;\n\n  constructor(\n    public idl: IDL.Type,\n    public ui: UIConfig,\n  ) {\n    const status = document.createElement('span');\n    status.className = 'status';\n    this.status = status;\n\n    if (ui.input) {\n      ui.input.addEventListener('blur', () => {\n        if ((ui.input as HTMLInputElement).value === '') {\n          return;\n        }\n        this.parse();\n      });\n      ui.input.addEventListener('input', () => {\n        status.style.display = 'none';\n        ui.input!.classList.remove('reject');\n      });\n    }\n  }\n  public isRejected(): boolean {\n    return this.value === undefined;\n  }\n\n  public parse(config: ParseConfig = {}): any {\n    if (this.ui.form) {\n      const value = this.ui.form.parse(config);\n      this.value = value;\n      return value;\n    }\n\n    if (this.ui.input) {\n      const input = this.ui.input as HTMLInputElement;\n      try {\n        const value = this.ui.parse(this.idl, config, input.value);\n        if (!this.idl.covariant(value)) {\n          throw new Error(`${input.value} is not of type ${this.idl.display()}`);\n        }\n        this.status.style.display = 'none';\n        this.value = value;\n        return value;\n      } catch (err) {\n        input.classList.add('reject');\n        this.status.style.display = 'block';\n        this.status.innerHTML = 'InputError: ' + (err as Error).message;\n        this.value = undefined;\n        return undefined;\n      }\n    }\n    return null;\n  }\n  public render(dom: HTMLElement): void {\n    const container = document.createElement('span');\n    if (this.label) {\n      const label = document.createElement('label');\n      label.innerText = this.label;\n      container.appendChild(label);\n    }\n    if (this.ui.input) {\n      container.appendChild(this.ui.input);\n      container.appendChild(this.status);\n    }\n\n    if (this.ui.form) {\n      this.ui.form.render(container);\n    }\n    dom.appendChild(container);\n  }\n}\n\nexport abstract class InputForm {\n  public form: InputBox[] = [];\n  constructor(public ui: FormConfig) {}\n\n  public abstract parse(config: ParseConfig): any;\n  public abstract generateForm(): any;\n  public renderForm(dom: HTMLElement): void {\n    if (this.ui.container) {\n      this.form.forEach(e => e.render(this.ui.container!));\n      dom.appendChild(this.ui.container);\n    } else {\n      this.form.forEach(e => e.render(dom));\n    }\n  }\n  public render(dom: HTMLElement): void {\n    if (this.ui.open && this.ui.event) {\n      dom.appendChild(this.ui.open);\n      const form = this;\n\n      form.ui.open!.addEventListener(form.ui.event!, () => {\n        // Remove old form\n        if (form.ui.container) {\n          form.ui.container.innerHTML = '';\n        } else {\n          const oldContainer = form.ui.open!.nextElementSibling;\n          if (oldContainer) {\n            oldContainer.parentNode!.removeChild(oldContainer);\n          }\n        }\n        // Render form\n        form.generateForm();\n        form.renderForm(dom);\n      });\n    } else {\n      this.generateForm();\n      this.renderForm(dom);\n    }\n  }\n}\n\nexport class RecordForm extends InputForm {\n  constructor(\n    public fields: Array<[string, IDL.Type]>,\n    public ui: FormConfig,\n  ) {\n    super(ui);\n  }\n  public generateForm(): void {\n    this.form = this.fields.map(([key, type]) => {\n      const input = this.ui.render(type);\n      // eslint-disable-next-line\n      if (this.ui.labelMap && this.ui.labelMap.hasOwnProperty(key)) {\n        input.label = this.ui.labelMap[key] + ' ';\n      } else {\n        input.label = key + ' ';\n      }\n      return input;\n    });\n  }\n  public parse(config: ParseConfig): Record<string, any> | undefined {\n    const v: Record<string, any> = {};\n    this.fields.forEach(([key, _], i) => {\n      const value = this.form[i].parse(config);\n      v[key] = value;\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return v;\n  }\n}\n\nexport class TupleForm extends InputForm {\n  constructor(\n    public components: IDL.Type[],\n    public ui: FormConfig,\n  ) {\n    super(ui);\n  }\n  public generateForm(): void {\n    this.form = this.components.map(type => {\n      const input = this.ui.render(type);\n      return input;\n    });\n  }\n  public parse(config: ParseConfig): any[] | undefined {\n    const v: any[] = [];\n    this.components.forEach((_, i) => {\n      const value = this.form[i].parse(config);\n      v.push(value);\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return v;\n  }\n}\n\nexport class VariantForm extends InputForm {\n  constructor(\n    public fields: Array<[string, IDL.Type]>,\n    public ui: FormConfig,\n  ) {\n    super(ui);\n  }\n  public generateForm(): void {\n    const index = (this.ui.open as HTMLSelectElement).selectedIndex;\n    const [_, type] = this.fields[index];\n    const variant = this.ui.render(type);\n    this.form = [variant];\n  }\n  public parse(config: ParseConfig): Record<string, any> | undefined {\n    const select = this.ui.open as HTMLSelectElement;\n    const selected = select.options[select.selectedIndex].value;\n    const value = this.form[0].parse(config);\n    if (value === undefined) {\n      return undefined;\n    }\n    const v: Record<string, any> = {};\n    v[selected] = value;\n    return v;\n  }\n}\n\nexport class OptionForm extends InputForm {\n  constructor(\n    public ty: IDL.Type,\n    public ui: FormConfig,\n  ) {\n    super(ui);\n  }\n  public generateForm(): void {\n    if ((this.ui.open as HTMLInputElement).checked) {\n      const opt = this.ui.render(this.ty);\n      this.form = [opt];\n    } else {\n      this.form = [];\n    }\n  }\n  public parse<T>(config: ParseConfig): [T] | [] | undefined {\n    if (this.form.length === 0) {\n      return [];\n    } else {\n      const value = this.form[0].parse(config);\n      if (value === undefined) {\n        return undefined;\n      }\n      return [value];\n    }\n  }\n}\n\nexport class VecForm extends InputForm {\n  constructor(\n    public ty: IDL.Type,\n    public ui: FormConfig,\n  ) {\n    super(ui);\n  }\n  public generateForm(): void {\n    const len = +(this.ui.open as HTMLInputElement).value;\n    this.form = [];\n    for (let i = 0; i < len; i++) {\n      const t = this.ui.render(this.ty);\n      this.form.push(t);\n    }\n  }\n  public parse<T>(config: ParseConfig): T[] | undefined {\n    const value = this.form.map(input => {\n      return input.parse(config);\n    });\n    if (this.form.some(input => input.isRejected())) {\n      return undefined;\n    }\n    return value;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-empty-object-type */\n\nexport interface JsonArray extends Array<JsonValue> {}\n\nexport interface JsonObject extends Record<string, JsonValue> {}\n\nexport type JsonValue = boolean | string | number | bigint | JsonArray | JsonObject;\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "Principal", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "IDLTypeIds", "IdlTypeName", "Principal", "import_dist", "import_dist"]
}
