{
  "version": 3,
  "sources": ["../../node_modules/@dfinity/identity/src/index.ts", "../../node_modules/@dfinity/identity/src/identity/ed25519.ts", "../../node_modules/@dfinity/identity/src/identity/ecdsa.ts", "../../node_modules/@dfinity/identity/src/identity/delegation.ts", "../../node_modules/@dfinity/identity/src/identity/partial.ts", "../../node_modules/@dfinity/identity/src/identity/webauthn.ts"],
  "sourcesContent": ["export { Ed25519KeyIdentity, Ed25519PublicKey } from './identity/ed25519.ts';\nexport * from './identity/ecdsa.ts';\nexport * from './identity/delegation.ts';\nexport * from './identity/partial.ts';\nexport { WebAuthnIdentity } from './identity/webauthn.ts';\nexport { wrapDER, unwrapDER, DER_COSE_OID, ED25519_OID } from '@dfinity/agent';\n\n/**\n * @deprecated due to size of dependencies. Use `@dfinity/identity-secp256k1` instead.\n */\nexport class Secp256k1KeyIdentity {\n  constructor() {\n    throw new Error(\n      'Secp256k1KeyIdentity has been moved to a new repo: @dfinity/identity-secp256k1',\n    );\n  }\n}\n", "import {\n  type DerEncodedPublicKey,\n  type KeyPair,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  ED25519_OID,\n  unwrapDER,\n  wrapDER,\n} from '@dfinity/agent';\nimport { uint8Equals, uint8FromBufLike } from '@dfinity/candid';\nimport { ed25519 } from '@noble/curves/ed25519';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\ndeclare type KeyLike = PublicKey | DerEncodedPublicKey | ArrayBuffer | ArrayBufferView;\n\nfunction isObject(value: unknown) {\n  return value !== null && typeof value === 'object';\n}\n\nexport class Ed25519PublicKey implements PublicKey {\n  /**\n   * Construct Ed25519PublicKey from an existing PublicKey\n   * @param {unknown} maybeKey - existing PublicKey, ArrayBuffer, DerEncodedPublicKey, or hex string\n   * @returns {Ed25519PublicKey} Instance of Ed25519PublicKey\n   */\n  public static from(maybeKey: unknown): Ed25519PublicKey {\n    if (typeof maybeKey === 'string') {\n      const key = hexToBytes(maybeKey);\n      return this.fromRaw(key);\n    } else if (isObject(maybeKey)) {\n      const key = maybeKey as KeyLike;\n      if (isObject(key) && Object.hasOwnProperty.call(key, '__derEncodedPublicKey__')) {\n        return this.fromDer(key as DerEncodedPublicKey);\n      } else if (ArrayBuffer.isView(key)) {\n        const view = key as ArrayBufferView;\n        return this.fromRaw(uint8FromBufLike(view.buffer));\n      } else if (key instanceof ArrayBuffer) {\n        return this.fromRaw(uint8FromBufLike(key));\n      } else if ('rawKey' in key && key.rawKey instanceof Uint8Array) {\n        return this.fromRaw(key.rawKey);\n      } else if ('derKey' in key) {\n        return this.fromDer(key.derKey as DerEncodedPublicKey);\n      } else if ('toDer' in key) {\n        return this.fromDer(key.toDer());\n      }\n    }\n    throw new Error('Cannot construct Ed25519PublicKey from the provided key.');\n  }\n\n  public static fromRaw(rawKey: Uint8Array): Ed25519PublicKey {\n    return new Ed25519PublicKey(rawKey);\n  }\n\n  public static fromDer(derKey: DerEncodedPublicKey): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.derDecode(derKey));\n  }\n\n  // The length of Ed25519 public keys is always 32 bytes.\n  private static RAW_KEY_LENGTH = 32;\n\n  private static derEncode(publicKey: Uint8Array): DerEncodedPublicKey {\n    const key = wrapDER(publicKey, ED25519_OID) as DerEncodedPublicKey;\n    key.__derEncodedPublicKey__ = undefined;\n    return key;\n  }\n\n  private static derDecode(key: DerEncodedPublicKey): Uint8Array {\n    const unwrapped = unwrapDER(key, ED25519_OID);\n    if (unwrapped.length !== this.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    return unwrapped;\n  }\n\n  #rawKey: Uint8Array;\n\n  public get rawKey(): Uint8Array {\n    return this.#rawKey;\n  }\n\n  #derKey: DerEncodedPublicKey;\n\n  public get derKey(): DerEncodedPublicKey {\n    return this.#derKey;\n  }\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  private constructor(key: Uint8Array) {\n    if (key.byteLength !== Ed25519PublicKey.RAW_KEY_LENGTH) {\n      throw new Error('An Ed25519 public key must be exactly 32bytes long');\n    }\n    this.#rawKey = key;\n    this.#derKey = Ed25519PublicKey.derEncode(key);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this.derKey;\n  }\n\n  public toRaw(): Uint8Array {\n    return this.rawKey;\n  }\n}\n\n/**\n * Ed25519KeyIdentity is an implementation of SignIdentity that uses Ed25519 keys. This class is used to sign and verify messages for an agent.\n */\nexport class Ed25519KeyIdentity extends SignIdentity {\n  /**\n   * Generate a new Ed25519KeyIdentity.\n   * @param seed a 32-byte seed for the private key. If not provided, a random seed will be generated.\n   * @returns Ed25519KeyIdentity\n   */\n  public static generate(seed?: Uint8Array): Ed25519KeyIdentity {\n    if (seed && seed.length !== 32) {\n      throw new Error('Ed25519 Seed needs to be 32 bytes long.');\n    }\n    if (!seed) seed = ed25519.utils.randomPrivateKey();\n    // Check if the seed is all zeros\n    if (uint8Equals(seed, new Uint8Array(new Array(32).fill(0)))) {\n      console.warn(\n        'Seed is all zeros. This is not a secure seed. Please provide a seed with sufficient entropy if this is a production environment.',\n      );\n    }\n    const sk = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      sk[i] = seed[i];\n    }\n\n    const pk = ed25519.getPublicKey(sk);\n    return Ed25519KeyIdentity.fromKeyPair(pk, sk);\n  }\n\n  public static fromParsedJson(obj: JsonnableEd25519KeyIdentity): Ed25519KeyIdentity {\n    const [publicKeyDer, privateKeyRaw] = obj;\n    return new Ed25519KeyIdentity(\n      Ed25519PublicKey.fromDer(hexToBytes(publicKeyDer) as DerEncodedPublicKey),\n      hexToBytes(privateKeyRaw),\n    );\n  }\n\n  public static fromJSON(json: string): Ed25519KeyIdentity {\n    const parsed = JSON.parse(json);\n    if (Array.isArray(parsed)) {\n      if (typeof parsed[0] === 'string' && typeof parsed[1] === 'string') {\n        return this.fromParsedJson([parsed[0], parsed[1]]);\n      } else {\n        throw new Error('Deserialization error: JSON must have at least 2 items.');\n      }\n    }\n    throw new Error(`Deserialization error: Invalid JSON type for string: ${JSON.stringify(json)}`);\n  }\n\n  public static fromKeyPair(publicKey: Uint8Array, privateKey: Uint8Array): Ed25519KeyIdentity {\n    return new Ed25519KeyIdentity(Ed25519PublicKey.fromRaw(publicKey), privateKey);\n  }\n\n  public static fromSecretKey(secretKey: Uint8Array): Ed25519KeyIdentity {\n    const publicKey = ed25519.getPublicKey(secretKey);\n    return Ed25519KeyIdentity.fromKeyPair(publicKey, secretKey);\n  }\n\n  #publicKey: Ed25519PublicKey;\n  #privateKey: Uint8Array;\n\n  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.\n  protected constructor(publicKey: PublicKey, privateKey: Uint8Array) {\n    super();\n    this.#publicKey = Ed25519PublicKey.from(publicKey);\n    this.#privateKey = privateKey;\n  }\n\n  /**\n   * Serialize this key to JSON.\n   */\n  public toJSON(): JsonnableEd25519KeyIdentity {\n    return [bytesToHex(this.#publicKey.toDer()), bytesToHex(this.#privateKey)];\n  }\n\n  /**\n   * Return a copy of the key pair.\n   */\n  public getKeyPair(): KeyPair {\n    return {\n      secretKey: this.#privateKey,\n      publicKey: this.#publicKey,\n    };\n  }\n\n  /**\n   * Return the public key.\n   */\n  public getPublicKey(): Required<PublicKey> {\n    return this.#publicKey;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param challenge - challenge to sign with this identity's secretKey, producing a signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    // Some implementations of Ed25519 private keys append a public key to the end of the private key. We only want the private key.\n    const signature = ed25519.sign(challenge, this.#privateKey.slice(0, 32));\n    // add { __signature__: void; } to the signature to make it compatible with the agent\n\n    Object.defineProperty(signature, '__signature__', {\n      enumerable: false,\n      value: undefined,\n    });\n\n    return signature as Signature;\n  }\n\n  /**\n   * Verify\n   * @param sig - signature to verify\n   * @param msg - message to verify\n   * @param pk - public key\n   * @returns - true if the signature is valid, false otherwise\n   */\n  public static verify(\n    sig: ArrayBuffer | Uint8Array | string,\n    msg: ArrayBuffer | Uint8Array | string,\n    pk: ArrayBuffer | Uint8Array | string,\n  ) {\n    const [signature, message, publicKey] = [sig, msg, pk].map(x => {\n      if (typeof x === 'string') {\n        x = hexToBytes(x);\n      }\n      return uint8FromBufLike(x);\n    });\n    return ed25519.verify(signature, message, publicKey);\n  }\n}\n\ntype PublicKeyHex = string;\ntype SecretKeyHex = string;\nexport type JsonnableEd25519KeyIdentity = [PublicKeyHex, SecretKeyHex];\n", "import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n} from '@dfinity/agent';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\n/**\n * Options used in a {@link ECDSAKeyIdentity}\n */\nexport type CryptoKeyOptions = {\n  extractable?: boolean;\n  keyUsages?: KeyUsage[];\n  subtleCrypto?: SubtleCrypto;\n};\n\nexport class CryptoError extends Error {\n  constructor(public readonly message: string) {\n    super(message);\n    Object.setPrototypeOf(this, CryptoError.prototype);\n  }\n}\n\nexport interface DerCryptoKey extends CryptoKey {\n  toDer: () => DerEncodedPublicKey;\n}\n\n/**\n * Utility method to ensure that a subtleCrypto implementation is provided or is available in the global context\n * @param subtleCrypto SubtleCrypto implementation\n * @returns subleCrypto\n */\nfunction _getEffectiveCrypto(subtleCrypto: CryptoKeyOptions['subtleCrypto']): SubtleCrypto {\n  if (typeof global !== 'undefined' && global['crypto'] && global['crypto']['subtle']) {\n    return global['crypto']['subtle'];\n  }\n  if (subtleCrypto) {\n    return subtleCrypto;\n  } else if (typeof crypto !== 'undefined' && crypto['subtle']) {\n    return crypto.subtle;\n  } else {\n    throw new CryptoError(\n      'Global crypto was not available and none was provided. Please inlcude a SubtleCrypto implementation. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto',\n    );\n  }\n}\n\n/**\n * An identity interface that wraps an ECDSA keypair using the P-256 named curve. Supports DER-encoding and decoding for agent calls\n */\nexport class ECDSAKeyIdentity extends SignIdentity {\n  /**\n   * Generates a randomly generated identity for use in calls to the Internet Computer.\n   * @param {CryptoKeyOptions} options optional settings\n   * @param {CryptoKeyOptions['extractable']} options.extractable - whether the key should allow itself to be used. Set to false for maximum security.\n   * @param {CryptoKeyOptions['keyUsages']} options.keyUsages - a list of key usages that the key can be used for\n   * @param {CryptoKeyOptions['subtleCrypto']} options.subtleCrypto interface\n   * @returns a {@link ECDSAKeyIdentity}\n   */\n  public static async generate(options?: CryptoKeyOptions): Promise<ECDSAKeyIdentity> {\n    const { extractable = false, keyUsages = ['sign', 'verify'], subtleCrypto } = options ?? {};\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const keyPair = await effectiveCrypto.generateKey(\n      {\n        name: 'ECDSA',\n        namedCurve: 'P-256',\n      },\n      extractable,\n      keyUsages,\n    );\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n\n    return new this(keyPair, derKey, effectiveCrypto);\n  }\n\n  /**\n   * generates an identity from a public and private key. Please ensure that you are generating these keys securely and protect the user's private key\n   * @param keyPair a CryptoKeyPair\n   * @param subtleCrypto - a SubtleCrypto interface in case one is not available globally\n   * @returns an {@link ECDSAKeyIdentity}\n   */\n  public static async fromKeyPair(\n    keyPair: CryptoKeyPair | { privateKey: CryptoKey; publicKey: CryptoKey },\n    subtleCrypto?: SubtleCrypto,\n  ): Promise<ECDSAKeyIdentity> {\n    const effectiveCrypto = _getEffectiveCrypto(subtleCrypto);\n    const derKey: DerEncodedPublicKey = uint8FromBufLike(\n      await effectiveCrypto.exportKey('spki', keyPair.publicKey),\n    );\n    Object.assign(derKey, {\n      __derEncodedPublicKey__: undefined,\n    });\n    return new ECDSAKeyIdentity(keyPair, derKey, effectiveCrypto);\n  }\n\n  protected _derKey: DerEncodedPublicKey;\n  protected _keyPair: CryptoKeyPair;\n  protected _subtleCrypto: SubtleCrypto;\n\n  // `fromKeyPair` and `generate` should be used for instantiation, not this constructor.\n  protected constructor(\n    keyPair: CryptoKeyPair,\n    derKey: DerEncodedPublicKey,\n    subtleCrypto: SubtleCrypto,\n  ) {\n    super();\n    this._keyPair = keyPair;\n    this._derKey = derKey;\n    this._subtleCrypto = subtleCrypto;\n  }\n\n  /**\n   * Return the internally-used key pair.\n   * @returns a CryptoKeyPair\n   */\n  public getKeyPair(): CryptoKeyPair {\n    return this._keyPair;\n  }\n\n  /**\n   * Return the public key.\n   * @returns an {@link PublicKey & DerCryptoKey}\n   */\n  public getPublicKey(): PublicKey & DerCryptoKey {\n    const derKey = this._derKey;\n    const key: DerCryptoKey = Object.create(this._keyPair.publicKey);\n    key.toDer = function () {\n      return derKey;\n    };\n\n    return key;\n  }\n\n  /**\n   * Signs a blob of data, with this identity's private key.\n   * @param {Uint8Array} challenge - challenge to sign with this identity's secretKey, producing a signature\n   * @returns {Promise<Signature>} signature\n   */\n  public async sign(challenge: Uint8Array): Promise<Signature> {\n    const params: EcdsaParams = {\n      name: 'ECDSA',\n      hash: { name: 'SHA-256' },\n    };\n    const signature = uint8FromBufLike(\n      await this._subtleCrypto.sign(params, this._keyPair.privateKey, challenge),\n    );\n\n    Object.assign(signature, {\n      __signature__: undefined,\n    });\n\n    return signature as Signature;\n  }\n}\n\nexport default ECDSAKeyIdentity;\n", "import {\n  type DerEncodedPublicKey,\n  type HttpAgentRequest,\n  type PublicKey,\n  requestIdOf,\n  type Signature,\n  SignIdentity,\n  IC_REQUEST_DOMAIN_SEPARATOR,\n  IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n  ToCborValue,\n} from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { PartialIdentity } from './partial.ts';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nfunction _parseBlob(value: unknown): Uint8Array {\n  if (typeof value !== 'string' || value.length < 64) {\n    throw new Error('Invalid public key.');\n  }\n\n  return hexToBytes(value);\n}\n\n/**\n * A single delegation object that is signed by a private key. This is constructed by\n * `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport class Delegation implements ToCborValue {\n  constructor(\n    public readonly pubkey: Uint8Array,\n    public readonly expiration: bigint,\n    public readonly targets?: Principal[],\n  ) {}\n\n  public toCborValue() {\n    return {\n      pubkey: this.pubkey,\n      expiration: this.expiration,\n      ...(this.targets && {\n        targets: this.targets,\n      }),\n    };\n  }\n\n  public toJSON(): JsonnableDelegation {\n    // every string should be hex and once-de-hexed,\n    // discoverable what it is (e.g. de-hex to get JSON with a 'type' property, or de-hex to DER\n    // with an OID). After de-hex, if it's not obvious what it is, it's an ArrayBuffer.\n    return {\n      expiration: this.expiration.toString(16),\n      pubkey: bytesToHex(this.pubkey),\n      ...(this.targets && { targets: this.targets.map(p => p.toHex()) }),\n    };\n  }\n}\n\n/**\n * Type of ReturnType<Delegation.toJSON>.\n * The goal here is to stringify all non-JSON-compatible types to some bytes representation we can\n * stringify as hex.\n * (Hex shouldn't be ambiguous ever, because you can encode as DER with semantic OIDs).\n */\ninterface JsonnableDelegation {\n  // A BigInt of Nanoseconds since epoch as hex\n  expiration: string;\n  // Hexadecimal representation of the DER public key.\n  pubkey: string;\n  // Array of strings, where each string is hex of principal blob (*NOT* textual representation).\n  targets?: string[];\n}\n\n/**\n * A signed delegation, which lends its identity to the public key in the delegation\n * object. This is constructed by `DelegationChain.create()`.\n *\n * {@see DelegationChain}\n */\nexport interface SignedDelegation {\n  delegation: Delegation;\n  signature: Signature;\n}\n\n/**\n * Sign a single delegation object for a period of time.\n * @param from The identity that lends its delegation.\n * @param to The identity that receives the delegation.\n * @param expiration An expiration date for this delegation.\n * @param targets Limit this delegation to the target principals.\n */\nasync function _createSingleDelegation(\n  from: SignIdentity,\n  to: PublicKey,\n  expiration: Date,\n  targets?: Principal[],\n): Promise<SignedDelegation> {\n  const delegation: Delegation = new Delegation(\n    to.toDer(),\n    BigInt(+expiration) * BigInt(1000000), // In nanoseconds.\n    targets,\n  );\n  // The signature is calculated by signing the concatenation of the domain separator\n  // and the message.\n  // Note: To ensure Safari treats this as a user gesture, ensure to not use async methods\n  // besides the actualy webauthn functionality (such as `sign`). Safari will de-register\n  // a user gesture if you await an async call thats not fetch, xhr, or setTimeout.\n  const challenge = new Uint8Array([\n    ...IC_REQUEST_AUTH_DELEGATION_DOMAIN_SEPARATOR,\n    ...new Uint8Array(requestIdOf({ ...delegation })),\n  ]);\n  const signature = await from.sign(challenge);\n\n  return {\n    delegation,\n    signature,\n  };\n}\n\nexport interface JsonnableDelegationChain {\n  publicKey: string;\n  delegations: Array<{\n    signature: string;\n    delegation: {\n      pubkey: string;\n      expiration: string;\n      targets?: string[];\n    };\n  }>;\n}\n\n/**\n * A chain of delegations. This is JSON Serializable.\n * This is the object to serialize and pass to a DelegationIdentity. It does not keep any\n * private keys.\n */\nexport class DelegationChain {\n  /**\n   * Create a delegation chain between two (or more) keys. By default, the expiration time\n   * will be very short (15 minutes).\n   *\n   * To build a chain of more than 2 identities, this function needs to be called multiple times,\n   * passing the previous delegation chain into the options argument. For example:\n   * @example\n   * const rootKey = createKey();\n   * const middleKey = createKey();\n   * const bottomeKey = createKey();\n   *\n   * const rootToMiddle = await DelegationChain.create(\n   *   root, middle.getPublicKey(), Date.parse('2100-01-01'),\n   * );\n   * const middleToBottom = await DelegationChain.create(\n   *   middle, bottom.getPublicKey(), Date.parse('2100-01-01'), { previous: rootToMiddle },\n   * );\n   *\n   * // We can now use a delegation identity that uses the delegation above:\n   * const identity = DelegationIdentity.fromDelegation(bottomKey, middleToBottom);\n   * @param from The identity that will delegate.\n   * @param to The identity that gets delegated. It can now sign messages as if it was the\n   *           identity above.\n   * @param expiration The length the delegation is valid. By default, 15 minutes from calling\n   *                   this function.\n   * @param options A set of options for this delegation. expiration and previous\n   * @param options.previous - Another DelegationChain that this chain should start with.\n   * @param options.targets - targets that scope the delegation (e.g. Canister Principals)\n   */\n  public static async create(\n    from: SignIdentity,\n    to: PublicKey,\n    expiration: Date = new Date(Date.now() + 15 * 60 * 1000),\n    options: {\n      previous?: DelegationChain;\n      targets?: Principal[];\n    } = {},\n  ): Promise<DelegationChain> {\n    const delegation = await _createSingleDelegation(from, to, expiration, options.targets);\n    return new DelegationChain(\n      [...(options.previous?.delegations || []), delegation],\n      options.previous?.publicKey || from.getPublicKey().toDer(),\n    );\n  }\n\n  /**\n   * Creates a DelegationChain object from a JSON string.\n   * @param json The JSON string to parse.\n   */\n  public static fromJSON(json: string | JsonnableDelegationChain): DelegationChain {\n    const { publicKey, delegations } = typeof json === 'string' ? JSON.parse(json) : json;\n    if (!Array.isArray(delegations)) {\n      throw new Error('Invalid delegations.');\n    }\n\n    const parsedDelegations: SignedDelegation[] = delegations.map(signedDelegation => {\n      const { delegation, signature } = signedDelegation;\n      const { pubkey, expiration, targets } = delegation;\n      if (targets !== undefined && !Array.isArray(targets)) {\n        throw new Error('Invalid targets.');\n      }\n\n      return {\n        delegation: new Delegation(\n          _parseBlob(pubkey),\n          BigInt('0x' + expiration), // expiration in JSON is an hexa string (See toJSON() below).\n          targets &&\n            targets.map((t: unknown) => {\n              if (typeof t !== 'string') {\n                throw new Error('Invalid target.');\n              }\n              return Principal.fromHex(t);\n            }),\n        ),\n        signature: _parseBlob(signature) as Signature,\n      };\n    });\n\n    return new this(parsedDelegations, _parseBlob(publicKey) as DerEncodedPublicKey);\n  }\n\n  /**\n   * Creates a DelegationChain object from a list of delegations and a DER-encoded public key.\n   * @param delegations The list of delegations.\n   * @param publicKey The DER-encoded public key of the key-pair signing the first delegation.\n   */\n  public static fromDelegations(\n    delegations: SignedDelegation[],\n    publicKey: DerEncodedPublicKey,\n  ): DelegationChain {\n    return new this(delegations, publicKey);\n  }\n\n  protected constructor(\n    public readonly delegations: SignedDelegation[],\n    public readonly publicKey: DerEncodedPublicKey,\n  ) {}\n\n  public toJSON(): JsonnableDelegationChain {\n    return {\n      delegations: this.delegations.map(signedDelegation => {\n        const { delegation, signature } = signedDelegation;\n        const { targets } = delegation;\n        return {\n          delegation: {\n            expiration: delegation.expiration.toString(16),\n            pubkey: bytesToHex(delegation.pubkey),\n            ...(targets && {\n              targets: targets.map(t => t.toHex()),\n            }),\n          },\n          signature: bytesToHex(signature),\n        };\n      }),\n      publicKey: bytesToHex(this.publicKey),\n    };\n  }\n}\n\n/**\n * An Identity that adds delegation to a request. Everywhere in this class, the name\n * innerKey refers to the SignIdentity that is being used to sign the requests, while\n * originalKey is the identity that is being borrowed. More identities can be used\n * in the middle to delegate.\n */\nexport class DelegationIdentity extends SignIdentity {\n  /**\n   * Create a delegation without having access to delegateKey.\n   * @param key The key used to sign the requests.\n   * @param delegation A delegation object created using `createDelegation`.\n   */\n  public static fromDelegation(\n    key: Pick<SignIdentity, 'sign'>,\n    delegation: DelegationChain,\n  ): DelegationIdentity {\n    return new this(key, delegation);\n  }\n\n  protected constructor(\n    private _inner: Pick<SignIdentity, 'sign'>,\n    private _delegation: DelegationChain,\n  ) {\n    super();\n  }\n\n  public getDelegation(): DelegationChain {\n    return this._delegation;\n  }\n\n  public getPublicKey(): PublicKey {\n    return {\n      derKey: this._delegation.publicKey,\n      toDer: () => this._delegation.publicKey,\n    };\n  }\n  public sign(blob: Uint8Array): Promise<Signature> {\n    return this._inner.sign(blob);\n  }\n\n  public async transformRequest(request: HttpAgentRequest): Promise<unknown> {\n    const { body, ...fields } = request;\n    const requestId = await requestIdOf(body);\n    return {\n      ...fields,\n      body: {\n        content: body,\n        sender_sig: await this.sign(\n          new Uint8Array([...IC_REQUEST_DOMAIN_SEPARATOR, ...new Uint8Array(requestId)]),\n        ),\n        sender_delegation: this._delegation.delegations,\n        sender_pubkey: this._delegation.publicKey,\n      },\n    };\n  }\n}\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialDelegationIdentity extends PartialIdentity {\n  #delegation: DelegationChain;\n\n  /**\n   * The Delegation Chain of this identity.\n   */\n  get delegation(): DelegationChain {\n    return this.#delegation;\n  }\n\n  private constructor(inner: PublicKey, delegation: DelegationChain) {\n    super(inner);\n    this.#delegation = delegation;\n  }\n\n  /**\n   * Create a {@link PartialDelegationIdentity} from a {@link PublicKey} and a {@link DelegationChain}.\n   * @param key The {@link PublicKey} to delegate to.\n   * @param delegation a {@link DelegationChain} targeting the inner key.\n   */\n  public static fromDelegation(key: PublicKey, delegation: DelegationChain) {\n    return new PartialDelegationIdentity(key, delegation);\n  }\n}\n\n/**\n * List of things to check for a delegation chain validity.\n */\nexport interface DelegationValidChecks {\n  /**\n   * Check that the scope is amongst the scopes that this delegation has access to.\n   */\n  scope?: Principal | string | Array<Principal | string>;\n}\n\n/**\n * Analyze a DelegationChain and validate that it's valid, ie. not expired and apply to the\n * scope.\n * @param chain The chain to validate.\n * @param checks Various checks to validate on the chain.\n */\nexport function isDelegationValid(chain: DelegationChain, checks?: DelegationValidChecks): boolean {\n  // Verify that the no delegation is expired. If any are in the chain, returns false.\n  for (const { delegation } of chain.delegations) {\n    // prettier-ignore\n    if (+new Date(Number(delegation.expiration / BigInt(1000000))) <= +Date.now()) {\n      return false;\n    }\n  }\n\n  // Check the scopes.\n  const scopes: Principal[] = [];\n  const maybeScope = checks?.scope;\n  if (maybeScope) {\n    if (Array.isArray(maybeScope)) {\n      scopes.push(...maybeScope.map(s => (typeof s === 'string' ? Principal.fromText(s) : s)));\n    } else {\n      scopes.push(typeof maybeScope === 'string' ? Principal.fromText(maybeScope) : maybeScope);\n    }\n  }\n\n  for (const s of scopes) {\n    const scope = s.toText();\n    for (const { delegation } of chain.delegations) {\n      if (delegation.targets === undefined) {\n        continue;\n      }\n\n      let none = true;\n      for (const target of delegation.targets) {\n        if (target.toText() === scope) {\n          none = false;\n          break;\n        }\n      }\n      if (none) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n", "import { type Identity, type PublicKey } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\n\n/**\n * A partial delegated identity, representing a delegation chain and the public key that it targets\n */\nexport class PartialIdentity implements Identity {\n  #inner: PublicKey;\n\n  /**\n   * The raw public key of this identity.\n   */\n  get rawKey(): Uint8Array | undefined {\n    return this.#inner.rawKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  get derKey(): Uint8Array | undefined {\n    return this.#inner.derKey;\n  }\n\n  /**\n   * The DER-encoded public key of this identity.\n   */\n  public toDer(): Uint8Array {\n    return this.#inner.toDer();\n  }\n\n  /**\n   * The inner {@link PublicKey} used by this identity.\n   */\n  public getPublicKey(): PublicKey {\n    return this.#inner;\n  }\n\n  /**\n   * The {@link Principal} of this identity.\n   */\n  public getPrincipal(): Principal {\n    if (!this.#inner.rawKey) {\n      throw new Error('Cannot get principal from a public key without a raw key.');\n    }\n    return Principal.fromUint8Array(new Uint8Array(this.#inner.rawKey));\n  }\n\n  /**\n   * Required for the Identity interface, but cannot implemented for just a public key.\n   */\n  public transformRequest(): Promise<never> {\n    return Promise.reject(\n      'Not implemented. You are attempting to use a partial identity to sign calls, but this identity only has access to the public key.To sign calls, use a DelegationIdentity instead.',\n    );\n  }\n\n  constructor(inner: PublicKey) {\n    this.#inner = inner;\n  }\n}\n", "import {\n  type DerEncodedPublicKey,\n  type PublicKey,\n  type Signature,\n  SignIdentity,\n  wrapDER,\n  DER_COSE_OID,\n  Cbor,\n} from '@dfinity/agent';\nimport { bytesToHex, hexToBytes, randomBytes, bytesToUtf8 } from '@noble/hashes/utils';\nimport { uint8FromBufLike } from '@dfinity/candid';\n\nfunction _coseToDerEncodedBlob(cose: Uint8Array): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID) as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n  // Explicitly including toJSON method from the base PublicKeyCredential interface\n  toJSON: () => Record<string, unknown>;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: Uint8Array): Uint8Array {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: Uint8Array) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): Uint8Array {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment | null;\n\n  if (creds === null) {\n    return null;\n  }\n\n  return {\n    // do _not_ use ...creds here, as creds is not enumerable in all cases\n    id: creds.id,\n    response: creds.response,\n    type: creds.type,\n    authenticatorAttachment: creds.authenticatorAttachment,\n    getClientExtensionResults: creds.getClientExtensionResults,\n    // Some password managers will return a Uint8Array, so we ensure we return an ArrayBuffer.\n    rawId: creds.rawId,\n    toJSON: creds.toJSON.bind(creds), // Ensure the toJSON method is included\n  };\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(hexToBytes(rawId), hexToBytes(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (response.attestationObject === undefined) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = Cbor.decode<{ authData: Uint8Array }>(\n      new Uint8Array(response.attestationObject),\n    );\n\n    return new this(\n      uint8FromBufLike(creds.rawId),\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: Uint8Array,\n    cose: Uint8Array,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: Uint8Array): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n\n    const encoded = Cbor.encode({\n      authenticator_data: response.authenticatorData,\n      client_data_json: bytesToUtf8(new Uint8Array(response.clientDataJSON)),\n      signature: response.signature,\n    });\n\n    if (!encoded) {\n      throw new Error('failed to encode cbor');\n    }\n\n    Object.assign(encoded, {\n      __signature__: undefined,\n    });\n\n    return encoded as Signature;\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentity {\n    return {\n      publicKey: bytesToHex(this._publicKey.getCose()),\n      rawId: bytesToHex(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentity {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "_inner", "_delegation", "import_dist", "PubKeyCoseAlgo"]
}
